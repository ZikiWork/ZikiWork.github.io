<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线程池ThreadPoolExecutor分析</title>
    <link href="/2022/03/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%88%86%E6%9E%90/"/>
    <url>/2022/03/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="线程池生命周期及状态"><a href="#线程池生命周期及状态" class="headerlink" title="线程池生命周期及状态"></a>线程池生命周期及状态</h2><blockquote><p>RUNNING: 接收新任务，也处理队列任务</p></blockquote><blockquote><p>SHUTDOWN: 不接收新任务，但是处理队列任务</p></blockquote><blockquote><p>STOP:   不接收新任务，不处理队列任务并且中断正在进行的任务</p></blockquote><blockquote><p>TIDYING: 所有任务都终止，workerCount为零，线程状态转为TIDYING，将运行terminated()方法</p></blockquote><blockquote><p>TERMINATED: terminated() 方法执行完毕</p></blockquote><h2 id="任务执行流程"><a href="#任务执行流程" class="headerlink" title="任务执行流程"></a>任务执行流程</h2><blockquote><p>execute(Runnable command) –&gt; addWorker(Runnable firstTask,boolean core) –&gt;runWorker(Worker w)</p></blockquote><ul><li><p>线程池的工作线程由Worker类实现，通过ReentrantLock锁，把worker实例插入到HashSet中,并启动Worker中的线程。</p></li><li><p>而Worker类的构造方法实现可以看出：threadFactory创建线程thread时，将worker实例本身this作为参数传入，执行start()时，本质是调用Worker的run()方法，run() 又调用了外部的runWorker()方法。</p></li><li><p>firstTask执行完成之后，通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源</p></li></ul><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><ol><li><p>线程池是什么时候创建线程的？</p></li><li><p>任务runnable task是先放到core到maxThread之间的线程，还是先放到队列？</p></li><li><p>队列中的任务是什么时候取出来的？</p></li><li><p>什么时候会触发reject策略？</p></li><li><p>core到maxThread之间的线程什么时候会die?</p></li><li><p>task抛出异常，线程池中这个work thread还能运行其他任务吗?</p></li></ol><h2 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h2><p><a href="https://gitee.com/Cai_Programmer/pic-go/raw/master/9e743837-29f4-4510-bcce-44542ad8f338.jpg"><img src="https://gitee.com/Cai_Programmer/pic-go/raw/master/9e743837-29f4-4510-bcce-44542ad8f338.jpg" srcset="/img/loading.gif" lazyload></a></p><p>创建线程池都会调用核心构造方法<code>ThreadPoolExecutor</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                              TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>             Executors.defaultThreadFactory(), defaultHandler);<br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>corePoolSize:核心线程最大数量，通俗点来讲就是，线程池中常驻线程的最大数量<br>maximumPoolSize:线程池中运行最大线程数(包括核心线程和非核心线程)<br>keepAliveTime:线程池中空闲线程（仅适用于非核心线程）所能存活的最长时间<br>unit:存活时间单位，与keepAliveTime搭配使用<br>workQueue：存放任务的阻塞队列<br>handler:线程池饱和策略</p></blockquote><p>在new ThreadPoolExecutor()创建线程池时，Thread对象并没有初始化. 这里仅仅指定了初始参数；</p><p>###线程是在什么时候创建的呢？<br>当执行execute时，更具当前条件（核心线程数与队列情况）判断，创建work线程。<br>###执行execute</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>       <span class="hljs-keyword">int</span> c = ctl.get();<br>       <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<span class="hljs-comment">//当前线程数小于corePoolSize, 则创建新的核心worker对象</span><br>           <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>               <span class="hljs-keyword">return</span>;<br>           c = ctl.get();<br>       &#125;<br>       <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="hljs-comment">//如果当前线程数大于corePoolSize, 并偿试放入队列 workQueue.offer(command) , 放入成功后等待线程池调度</span><br>           <span class="hljs-keyword">int</span> recheck = ctl.get();<br>           <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>               reject(command);<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>               addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<span class="hljs-comment">//偿试放入队列 workQueue.offer(command) 失败， 增加一个非core的线程</span><br>           reject(command);<br>   &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>第一个if， 判断如果当前线程数小于corePoolSize, 则创建新的核心worker对象（Worker中指向Thread对象，保持引用，保证不会被GC回收）</p></blockquote><blockquote><p>第二个if,   判断如果当前线程数大于corePoolSize, 并偿试放入队列 workQueue.offer(command) , 放入成功后等待线程池调度【见后面的getTask()】<br>第三个if,  偿试放入队列 workQueue.offer(command) 失败， 增加一个非core的线程</p></blockquote><hr><p>###增加任务addWorker</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        w = <span class="hljs-keyword">new</span> Worker(firstTask);<span class="hljs-comment">//此处new work()创建线程</span><br>        <span class="hljs-keyword">final</span> Thread t = w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    workers.add(w);<span class="hljs-comment">//线程池this的worker容器，保持对线程的引用</span><br>                    <span class="hljs-keyword">int</span> s = workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();<span class="hljs-comment">//处理结束后，启动线程</span><br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>###new work()创建线程<br>work构造方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">      Worker(Runnable firstTask) &#123;<br>          setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>          <span class="hljs-keyword">this</span>.firstTask = firstTask;<br>          <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//创建线程</span><br>      &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>          runWorker(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//线程创建后，运行</span><br>      &#125;<br></code></pre></div></td></tr></table></figure><h3 id="runWorker-启动线程"><a href="#runWorker-启动线程" class="headerlink" title="runWorker 启动线程"></a>runWorker 启动线程</h3><p>线程启动后，又做了那些事情呢？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>      Thread wt = Thread.currentThread();<br>      Runnable task = w.firstTask;<br>      w.firstTask = <span class="hljs-keyword">null</span>;<br>      w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>      <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//通过getTask()获取任务</span><br>              w.lock();<br>              <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>              <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>              <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>              <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>              <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                   (Thread.interrupted() &amp;&amp;<br>                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                  !wt.isInterrupted())<br>                  wt.interrupt();<br>              <span class="hljs-keyword">try</span> &#123;<br>                  beforeExecute(wt, task);<br>                  Throwable thrown = <span class="hljs-keyword">null</span>;<br>                  <span class="hljs-keyword">try</span> &#123;<br>                      task.run();<br>                  &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                      thrown = x; <span class="hljs-keyword">throw</span> x;<br>                  &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                      thrown = x; <span class="hljs-keyword">throw</span> x;<br>                  &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                      thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                  &#125; <span class="hljs-keyword">finally</span> &#123;<br>                      afterExecute(task, thrown);<span class="hljs-comment">//执行结束后的清理工作</span><br>                  &#125;<br>              &#125; <span class="hljs-keyword">finally</span> &#123;<br>                  task = <span class="hljs-keyword">null</span>;<br>                  w.completedTasks++;<br>                  w.unlock();<br>              &#125;<br>          &#125;<br>          completedAbruptly = <span class="hljs-keyword">false</span>;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//如果抛出异常后执行以下方法</span><br>          processWorkerExit(w, completedAbruptly);<br>      &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>没抛异常时，会一直在while（task !=null || (task = getTask())!=null）中执行；<br>如果有异常时，再看一下processWorkerExit()</p></blockquote><h3 id="processWorkerExit-异常处理"><a href="#processWorkerExit-异常处理" class="headerlink" title="processWorkerExit 异常处理"></a>processWorkerExit 异常处理</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        decrementWorkerCount();<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        completedTaskCount += w.completedTasks;<br>        workers.remove(w);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    tryTerminate();<br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>            <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>从此可以看出有异常时 <strong>旧的worker会被删除（GC回收）</strong>，再创建新的Worker， 即有异常时 <strong>旧worker不可能再执行新的任务</strong></p></blockquote><p>##结论</p><p>###执行流程判断<br>当提交一个新任务，线程池的处理流程如下：</p><ul><li>判断线程池中核心线程数是否已达阈值corePoolSize,若否，则创建一个新核心线程执行任务</li><li>若核心线程数已达阈值corePoolSize,判断阻塞队列workQueue是否已满，若未满，则将新任务添加进阻塞队列</li><li>若满，再判断，线程池中线程数是否达到阈值maximumPoolSize,若否，则新建一个非核心线程执行任务。若达到阈值，则执行线程池饱和策略。</li></ul><p>线程池饱和策略分为一下几种：</p><ul><li>AbortPolicy:直接抛出一个异常，默认策略</li><li>DiscardPolicy: 直接丢弃任务</li><li>DiscardOldestPolicy:抛弃下一个将要被执行的任务(最旧任务)</li><li>CallerRunsPolicy:主线程中执行任务</li></ul><p>流程：<br><a href="https://gitee.com/Cai_Programmer/pic-go/raw/master/2f0a2292-8c67-4d5a-9d36-c95570607447.jpg"><img src="https://gitee.com/Cai_Programmer/pic-go/raw/master/2f0a2292-8c67-4d5a-9d36-c95570607447.jpg" srcset="/img/loading.gif" lazyload></a></p><hr><h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><blockquote><p>Q. 线程池是什么时候创建线程的？<br>A.任务提交的时候</p></blockquote><blockquote><p>Q.任务runnable task是先放到core到maxThread之间的线程，还是先放到队列？<br>A.先放队列!!!</p></blockquote><blockquote><p>Q. 队列中的任务是什么时候取出来的？<br>A. worker中 runWorker() 一个任务完成后，会取下一个任务</p></blockquote><blockquote><p>Q. 什么时候会触发reject策略？<br>A.队列满并且maxthread也满了， 还有新任务，默认策略是reject</p></blockquote><blockquote><p>Q. core到maxThread之间的线程什么时候会die?<br>A.  没有任务时，或者抛异常时。core线程也会die的，core到maxThread之间的线程有可能会晋升到core线程区间，core max只是个计数，线程并不是创建后就固定在一个区间了</p></blockquote><blockquote><p>Q. task抛出异常，线程池中这个work thread还能运行其他任务吗?<br>A. 不能。 但是会创建新的线程, 新线程可以运行其他task。</p></blockquote><p>参阅：</p><blockquote><ul><li><a href="https://links.jianshu.com/go?to=https://blog.csdn.net/programmer_at/article/details/79799267">Java线程池实现原理与源码解析(jdk1.8)</a></li><li><a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/yszzu/p/10122658.html">线程池ThreadPoolExecutor分析: 线程池是什么时候创建线程的，队列中的任务是什么时候取出来的？</a></li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 表按时间分区（内附脚本）</title>
    <link href="/2022/03/17/Mysql-%E8%A1%A8%E6%8C%89%E6%97%B6%E9%97%B4%E5%88%86%E5%8C%BA%EF%BC%88%E5%86%85%E9%99%84%E8%84%9A%E6%9C%AC%EF%BC%89/"/>
    <url>/2022/03/17/Mysql-%E8%A1%A8%E6%8C%89%E6%97%B6%E9%97%B4%E5%88%86%E5%8C%BA%EF%BC%88%E5%86%85%E9%99%84%E8%84%9A%E6%9C%AC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="mysql表分区的几种方式"><a href="#mysql表分区的几种方式" class="headerlink" title="mysql表分区的几种方式"></a>mysql表分区的几种方式</h3><p>参阅：<a href="https://www.cnblogs.com/mliudong/p/3625522.html" title="MySQL表的四种分区类型">MySQL表的四种分区类型</a></p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/73aa05cccd0241e3b0b1a0ba0b36b93a.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>常用的按时间分区可以按照年、月、日等条件用来分区，因为是按时间条件分区所以选用RANGE分区方式。</p><h4 id="分区的条件判断："><a href="#分区的条件判断：" class="headerlink" title="分区的条件判断："></a>分区的条件判断：</h4><ul><li>LESS THAN：如果是数值就是小于等于，时间则是小于。</li><li>LESS THAN MAX:不等于。</li><li>IN:包含于某某区间。</li></ul><h4 id="按实际分区的时间函数选用："><a href="#按实际分区的时间函数选用：" class="headerlink" title="按实际分区的时间函数选用："></a>按实际分区的时间函数选用：</h4><ul><li>按日分区切分时的条件可以用day()、to_days()时间函数，需要注意的是必须是返回值是整形的。</li><li>按月分区采用month()时间函数;</li><li>其他条件分区的时间函数：可查看：<a href="https://blog.csdn.net/qq_36216193/article/details/90404527">SQL语句：日期函数汇总</a></li></ul><p>其中按时间字段create_date按天分区，首先需要把date字段改成主键，后添加分区切分规则</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> js_sys_log <br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (id, create_date);  <span class="hljs-comment">--之前id是主键，所以这里第2主键为联合主键</span><br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>  js_sys_log  <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (create_date);<br></code></pre></div></td></tr></table></figure><p>为了便于管理分区名通常以“p时间”来命名。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">示例一：<br>    <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>  js_sys_log  <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> (to_days(create_date)) (<br>        <span class="hljs-keyword">PARTITION</span>  p20181101  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181101&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181102  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181102&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181103  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181103&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181104  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181104&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181105  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181105&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181106  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181106&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181107  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181107&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181108  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181108&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181109  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181109&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181110  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181110&#x27;</span>))，<br>        <span class="hljs-keyword">PARTITION</span>  p_other  <span class="hljs-keyword">VALUES</span> LESS THAN MAXVALUE );<br>    );<br></code></pre></div></td></tr></table></figure><h4 id="后期添加分区"><a href="#后期添加分区" class="headerlink" title="后期添加分区"></a>后期添加分区</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">示例二：<br>    <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>  js_sys_log  <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PARTITION</span> (<span class="hljs-keyword">PARTITION</span>  p20181111 <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DAYS (<span class="hljs-string">&#x27;2018-11-11&#x27;</span>)));<br></code></pre></div></td></tr></table></figure><h4 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">示例三：<br>    <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>  js_sys_log  <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PARTITION</span> p20181101;<br></code></pre></div></td></tr></table></figure><h4 id="查询MySQL的系统字典库得知所有的分区详情信息"><a href="#查询MySQL的系统字典库得知所有的分区详情信息" class="headerlink" title="查询MySQL的系统字典库得知所有的分区详情信息"></a>查询MySQL的系统字典库得知所有的分区详情信息</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">示例四：<br>    <span class="hljs-keyword">SELECT</span>  <span class="hljs-operator">*</span>  <span class="hljs-keyword">FROM</span>  information_schema. PARTITIONS  t  <span class="hljs-keyword">WHERE</span> t.PARTITION_NAME <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br></code></pre></div></td></tr></table></figure><h3 id="在分区创建后可以通过过程和事件控制自动增加表分区"><a href="#在分区创建后可以通过过程和事件控制自动增加表分区" class="headerlink" title="在分区创建后可以通过过程和事件控制自动增加表分区"></a>在分区创建后可以通过过程和事件控制自动增加表分区</h3><p>1.查看是否开启事件</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> &quot;event_scheduler&quot;;<br></code></pre></div></td></tr></table></figure><p>2.开启事件（本次设置中有效）</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> event_scheduler <span class="hljs-operator">=</span> <span class="hljs-keyword">on</span>;    <br>或<br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> event_scheduler <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>3.长期有效（配置文件设置）</p><p>my.cnf中设置 event_scheduler = on; 重启服务即可。</p><p>4.设置分区脚本</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">use test;<br>DELIMITER <span class="hljs-operator">||</span><br><span class="hljs-comment">-- 删除存储过程</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">procedure</span> if <span class="hljs-keyword">exists</span> 事件名称 <span class="hljs-operator">||</span><br><span class="hljs-comment">-- 注意：使用该存储过程必须保证相应数据库表中至少有一个手动分区</span><br><span class="hljs-comment">-- 创建存储过程[通过数据库名和对应表名]-建多少个分区，分区时间间隔为多少</span><br><span class="hljs-comment">-- databasename：创建分区的数据库</span><br><span class="hljs-comment">-- tablename：创建分区的表的名称</span><br><span class="hljs-comment">-- partition_number：一次创建多少个分区</span><br><span class="hljs-comment">-- partitiontype：分区类型[0按天分区，1按月分区，2按年分区]</span><br><span class="hljs-comment">-- gaps：分区间隔，如果分区类型为0则表示每个分区的间隔为 gaps天；</span><br><span class="hljs-comment">-- 如果分区类型为1则表示每个分区的间隔为 gaps月</span><br><span class="hljs-comment">-- 如果分区类型为2则表示每个分区的间隔为 gaps年</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> 事件名称 (<span class="hljs-keyword">in</span> databasename <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci,<span class="hljs-keyword">in</span> tablename <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci, <span class="hljs-keyword">in</span> partition_number <span class="hljs-type">int</span>, <span class="hljs-keyword">in</span> partitiontype <span class="hljs-type">int</span>, <span class="hljs-keyword">in</span> gaps <span class="hljs-type">int</span>)<br>L_END:<br><span class="hljs-keyword">begin</span>     <br>    <span class="hljs-keyword">declare</span> max_partition_description <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">declare</span> p_name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;       <br>    <span class="hljs-keyword">declare</span> p_description <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;   <br>    <span class="hljs-keyword">declare</span> isexist_partition <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>; <br> <span class="hljs-keyword">declare</span> i <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br>  <br> <span class="hljs-comment">-- 查看对应数据库对应表是否已经有手动分区[自动分区前提是必须有手动分区]</span><br>    <span class="hljs-keyword">select</span> partition_name <span class="hljs-keyword">into</span> isexist_partition <span class="hljs-keyword">from</span> information_schema.partitions <span class="hljs-keyword">where</span> table_schema <span class="hljs-operator">=</span> databasename  <span class="hljs-keyword">and</span> table_name <span class="hljs-operator">=</span> tablename limit <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">-- 如果不存在则打印错误并退出存储过程</span><br>    if isexist_partition <span class="hljs-operator">&lt;=&gt;</span> &quot;&quot; <span class="hljs-keyword">then</span><br>       <span class="hljs-keyword">select</span> &quot;partition table not is exist&quot; <span class="hljs-keyword">as</span> &quot;ERROR&quot;;<br>       leave L_END;<br>    <span class="hljs-keyword">end</span> if;<br> <br>    <span class="hljs-comment">-- 获取最大[降序获取]的分区描述[值]</span><br>    <span class="hljs-keyword">select</span> partition_description <span class="hljs-keyword">into</span> max_partition_description  <span class="hljs-keyword">from</span> information_schema.partitions <span class="hljs-keyword">where</span> table_schema <span class="hljs-operator">=</span> databasename  <span class="hljs-keyword">and</span> table_name <span class="hljs-operator">=</span> tablename <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> partition_description <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1</span>;<br>   <br>    <span class="hljs-comment">-- 如果最大分区没有,说明没有手动分区,则无法创建自动分区</span><br>    if max_partition_description <span class="hljs-operator">&lt;=&gt;</span> &quot;&quot; <span class="hljs-keyword">then</span><br>       <span class="hljs-keyword">select</span> &quot;partition table is error&quot; <span class="hljs-keyword">as</span> &quot;ERROR&quot;;<br>       leave L_END;<br>    <span class="hljs-keyword">end</span> if;<br> <br>    <span class="hljs-comment">-- 替换前后的单引号[&#x27;&#x27;两个引号表示一个单引号的转义]</span><br>    <span class="hljs-comment">-- set max_partition_description = REPLACE(max_partition_description, &#x27;&#x27;&#x27;&#x27;, &#x27;&#x27;);</span><br>    <span class="hljs-comment">-- 或使用如下语句</span><br>    <span class="hljs-keyword">set</span> max_partition_description <span class="hljs-operator">=</span> REPLACE(max_partition_description<span class="hljs-number">-1</span>, <span class="hljs-string">&#x27;\&#x27;&#x27;, &#x27;&#x27;);</span><br><span class="hljs-string"> </span><br><span class="hljs-string">    -- 自动创建number个分区</span><br><span class="hljs-string">    while (i &lt;= partition_number) do</span><br><span class="hljs-string">                 if (partitiontype = 0) then</span><br><span class="hljs-string">                     -- 每个分区按天递增,递增gaps天</span><br><span class="hljs-string">                     set p_description = DATE_ADD(FROM_DAYS(max_partition_description), interval i*gaps day); </span><br><span class="hljs-string">                 elseif (partitiontype = 1) then</span><br><span class="hljs-string">                     -- 每个分区按月递增,递增gaps月</span><br><span class="hljs-string">                     set p_description = DATE_ADD(FROM_DAYS(max_partition_description), interval i*gaps month); </span><br><span class="hljs-string">                 else </span><br><span class="hljs-string">                     -- 每个分区按年递增,递增gaps年</span><br><span class="hljs-string">                     set p_description = DATE_ADD(FROM_DAYS(max_partition_description), interval i*gaps year);</span><br><span class="hljs-string">                 end if;</span><br><span class="hljs-string">                 -- 删除空格</span><br><span class="hljs-string">                 set p_name = REPLACE(p_description, &#x27;</span> <span class="hljs-string">&#x27;, &#x27;&#x27;);</span><br><span class="hljs-string">                 -- 例如10.20的记录实际是less than 10.21</span><br><span class="hljs-string">                 set p_description = DATE_ADD(p_description, interval 1 day); </span><br><span class="hljs-string">                 -- 如果有横杆替换为空</span><br><span class="hljs-string">          set p_name = REPLACE(p_name, &#x27;</span><span class="hljs-operator">-</span><span class="hljs-string">&#x27;, &#x27;&#x27;);</span><br><span class="hljs-string">                 -- 删除时间冒号</span><br><span class="hljs-string">                 set p_name = REPLACE(p_name, &#x27;</span>:<span class="hljs-string">&#x27;, &#x27;&#x27;);</span><br><span class="hljs-string">                 -- alter table tablename add partition ( partition pname values less than (&#x27;</span><span class="hljs-number">2019</span><span class="hljs-number">-05</span><span class="hljs-number">-22</span> <span class="hljs-number">23</span>:<span class="hljs-number">59</span>:<span class="hljs-number">59</span><span class="hljs-string">&#x27;) );</span><br><span class="hljs-string">          set @sql=CONCAT(&#x27;</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">&#x27;, tablename ,&#x27;</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PARTITION</span> ( <span class="hljs-keyword">PARTITION</span> p<span class="hljs-string">&#x27;, p_name ,&#x27;</span> <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DAYS(\<span class="hljs-string">&#x27;&#x27;</span>, p_description ,<span class="hljs-string">&#x27;\&#x27;</span>)))<span class="hljs-string">&#x27;);</span><br><span class="hljs-string">                 -- set @sql=CONCAT(&#x27;</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">&#x27;, tablename ,&#x27;</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PARTITION</span> ( <span class="hljs-keyword">PARTITION</span> p<span class="hljs-string">&#x27;, p_name ,&#x27;</span> <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DAYS(\<span class="hljs-string">&#x27;&#x27;</span>, p_description ,<span class="hljs-string">&#x27;\&#x27;</span>)))<span class="hljs-string">&#x27;);</span><br><span class="hljs-string">                 -- 打印sql变量</span><br><span class="hljs-string">          -- select @sql;</span><br><span class="hljs-string">                 -- 准备sql语句</span><br><span class="hljs-string">          PREPARE stmt from @sql;</span><br><span class="hljs-string">                 -- 执行sql语句</span><br><span class="hljs-string">          EXECUTE stmt;</span><br><span class="hljs-string">                 -- 释放资源</span><br><span class="hljs-string">          DEALLOCATE PREPARE stmt;</span><br><span class="hljs-string">                 -- 递增变量</span><br><span class="hljs-string">          set i = (i + 1) ;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">    end while;          </span><br><span class="hljs-string">end ||</span><br><span class="hljs-string">-- 恢复语句中断符</span><br><span class="hljs-string">DELIMITER ;</span><br></code></pre></div></td></tr></table></figure><p>5.事件处理(on schedule every 1 day)</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">DELIMITER <span class="hljs-operator">||</span><br><span class="hljs-keyword">drop</span> event if <span class="hljs-keyword">exists</span> 事件名称 <span class="hljs-operator">||</span><br><span class="hljs-keyword">create</span> event 事件名称<br><span class="hljs-keyword">on</span> schedule <span class="hljs-keyword">every</span> <span class="hljs-number">1</span> <span class="hljs-keyword">day</span><br>starts <span class="hljs-string">&#x27;2019-05-22 23:59:59&#x27;</span><br>do<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">call</span> 事件名称 (<span class="hljs-string">&#x27;数据库名&#x27;</span>, <span class="hljs-string">&#x27;分区表名&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">END</span> <span class="hljs-operator">||</span><br>DELIMITER ;<br></code></pre></div></td></tr></table></figure><p>6.删除事件</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> EVENT [IF <span class="hljs-keyword">EXISTS</span>] 事件名称;<br></code></pre></div></td></tr></table></figure><p>7.查看事件</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> event;<br></code></pre></div></td></tr></table></figure><p>8.表分区查看</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">explain partitions <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 分区表名;<br></code></pre></div></td></tr></table></figure><hr><p>原文链接：<a href="https://blog.csdn.net/qq_36216193/article/details/90412637" title="mysql 表分区、按时间函数分区、删除分区、自动添加表分区">mysql 表分区、按时间函数分区、删除分区、自动添加表分区</a></p><p>推荐阅读：</p><ul><li><a href="https://blog.csdn.net/JesseYoung/article/details/35257527">https://blog.csdn.net/JesseYoung/article/details/35257527</a></li><li><a href="https://blog.csdn.net/qq_36216193/article/details/90412637">https://blog.csdn.net/qq_36216193/article/details/90412637</a></li><li><a href="https://blog.csdn.net/laoyang360/article/details/52886987" title="Mysql数据库表分区深入详解">Mysql数据库表分区深入详解</a></li><li><a href="https://juejin.cn/post/6844903495498203144" title="一个MySQL 5.7 分区表性能下降的案例分析">一个MySQL 5.7 分区表性能下降的案例分析</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>管理分布式Session的几种方式</title>
    <link href="/2022/03/17/%E7%AE%A1%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8FSession%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/03/17/%E7%AE%A1%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8FSession%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/Ziki_zhouyuxin/ArticleImages/raw/master/202201272149848.png" srcset="/img/loading.gif" lazyload></p><p>分布式Session实现方式：</p><h2 id="1-客户端存储"><a href="#1-客户端存储" class="headerlink" title="1.客户端存储"></a>1.客户端存储</h2><p>(基于Cookie管理)</p><p>这种方式每次发起请求的时候都需要将Session数据放到Cookie中传递给服务端。</p><ul><li><p>优点：不需要依赖额外外部存储，不需要额外配置。</p></li><li><p>缺点：不安全，易被盗取或篡改；Cookie数量和长度有限制，需要消耗更多网络带宽。</p></li><li><p>适用场景：数据不重要、不敏感且数据量小的情况。</p></li></ul><hr><h2 id="2-Session复制"><a href="#2-Session复制" class="headerlink" title="2.Session复制"></a>2.Session复制</h2><p>在支持Session复制的Web服务器上，通过修改Web服务器的配置，可以实现将Session同步到其它Web服务器上，达到每个Web服务器上都保存一致的Session。</p><p><img src="https://gitee.com/Ziki_zhouyuxin/ArticleImages/raw/master/20210530174912.png" srcset="/img/loading.gif" lazyload></p><ul><li><p>优点：代码上不需要做支持和修改。</p></li><li><p>缺点：需要依赖支持的Web服务器，一旦更换成不支持的Web服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，会造成服务器内存浪费。</p></li><li><p>适用场景：只适用于Web服务器比较少且<code>Session</code>数据量少的情况。</p></li><li><p>可用方案：开源方案<code>tomcat-redis-session-manager</code>。</p></li></ul><hr><h2 id="3-Session粘滞"><a href="#3-Session粘滞" class="headerlink" title="3.Session粘滞"></a>3.Session粘滞</h2><p>将用户的每次请求都通过某种方法强制·分发到某一个Web服务器上，只要这个Web服务器上存储了对应Session数据，就可以实现会话跟踪。</p><ul><li><p>优点：使用简单，没有额外开销。</p></li><li><p>缺点：一旦某个Web服务器重启或宕机，相对应的Session数据将会丢失，而且需要依赖负载均衡机制。</p></li><li><p>适用场景：发生故障对客户产生的影响较小；对稳定性要求不是很高的业务情景。</p></li><li><p>可用方案：以<code>Nginx</code>为例，在<code>upstream</code>模块配置ip_hash属性即可实现粘性Session。</p></li></ul><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">upstream mycluster&#123;<br>    #这里添加的是上面启动好的两台Tomcat服务器<br>    ip_hash;#粘性Session<br>    <span class="hljs-built_in"> server </span>192.168.22.229:8080 <span class="hljs-attribute">weight</span>=1;<br>    <span class="hljs-built_in"> server </span>192.168.22.230:8080 <span class="hljs-attribute">weight</span>=1;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>利用<code>Nginx</code>服务器的反向代理，将服务器A和服务器B进行代理，然后采用<code>ip_hash</code>的负载策略，将客户端和服务器进行绑定，也就是说客户端A第一次访问的是服务器B，那么第二次访问也必然是服务器B，这样就不存在session不一致的问题了。</p><p><img src="https://gitee.com/Ziki_zhouyuxin/ArticleImages/raw/master/20210530174915.png" srcset="/img/loading.gif" lazyload></p><hr><h2 id="4-Session集中管理"><a href="#4-Session集中管理" class="headerlink" title="4.Session集中管理"></a>4.Session集中管理</h2><p>在单独的服务器或服务器集群上使用缓存技术，如<code>Redis</code>存储Session数据，集中管理所有的Session，所有的Web服务器都从这个存储介质中存取对应的Session，实现Session共享。</p><p>这也是目前企业开发用到的比较多的一种分布式<code>session</code>解决方案。</p><p><img src="https://gitee.com/Ziki_zhouyuxin/ArticleImages/raw/master/20210530174917.png" srcset="/img/loading.gif" lazyload></p><ul><li><p>优点：可靠性高，减少Web服务器的资源开销。</p></li><li><p>缺点：实现上有些复杂，配置较多。</p></li><li><p>适用场景：Web服务器较多、要求高可用性的情况。</p></li><li><p>可用方案：开源方案Spring Session等。</p></li></ul><hr><p>参考：</p><ul><li><a href="https://www.cnblogs.com/daofaziran/p/10933221.html">https://www.cnblogs.com/daofaziran/p/10933221.html</a></li><li><a href="https://blog.csdn.net/javandroid/article/details/52959105">https://blog.csdn.net/javandroid/article/details/52959105</a></li><li><a href="https://www.jianshu.com/p/3dd4e06bdfa4">https://www.jianshu.com/p/3dd4e06bdfa4</a></li><li><a href="https://www.cnblogs.com/saoyou/p/11107488.html">https://www.cnblogs.com/saoyou/p/11107488.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Session</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长有效括号</title>
    <link href="/2021/08/29/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <url>/2021/08/29/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>s[i]</code> 为 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> longestValidParentheses(String s) &#123;<br>        Stack&lt;<span class="hljs-type">Integer</span>&gt; st = <span class="hljs-built_in">new</span> Stack&lt;<span class="hljs-type">Integer</span>&gt;();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ,start = <span class="hljs-number">0</span>;i &lt; s.length();i ++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>( s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) st.<span class="hljs-keyword">add</span>(i);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(!st.isEmpty()) <br>                &#123;<br>                    st.pop();<br>                    <span class="hljs-keyword">if</span>(st.isEmpty()) ans = Math.max(ans,i - <span class="hljs-keyword">start</span> + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">else</span> ans = Math.max(ans,i - st.peek());<br>                &#125;<br>                <span class="hljs-keyword">else</span> start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="具体过程如下："><a href="#具体过程如下：" class="headerlink" title="具体过程如下："></a>具体过程如下：</h3><ul><li><p>用栈维护当前待匹配的左括号的位置，同时用 start 记录一个新的可能合法的子串的起始位置，初始设为0。</p></li><li><p>如果s[i] ==’(‘，那么把i进栈。</p></li><li><p>如果s[i] == ‘)’,那么弹出栈顶元素 （代表栈顶的左括号匹配到了右括号），出栈后：</p></li></ul><p>如果栈为空，说明以当前右括号为右端点的合法括号序列的左端点为start，则更新答案 i - start + 1。</p><p>如果栈不为空，说明以当前右括号为右端点的合法括号序列的左端点为栈顶元素的下一个元素，则更新答案i - st.top() 。</p><p><img src="https://pic.leetcode-cn.com/1628390397-QMdXtd-file_1628390396777" srcset="/img/loading.gif" lazyload></p><ul><li><p>遇到右括号)且当前栈为空，则当前的 start 开始的子串不再可能为合法子串了，下一个合法子串的起始位置是 i + 1，更新 start = i + 1。</p></li><li><p>最后返回答案。</p></li></ul><p>实现细节： 栈保存的是下标。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>时间复杂度： O(n)，n 是给定字符串的长度。我们只需要遍历字符串一次即可。</p></li><li><p>空间复杂度： O(n)。栈的大小在最坏情况下会达到 n，因此空间复杂度为 O(n) 。</p></li></ul><hr><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号 - 力扣（LeetCode） (leetcode-cn.com)</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Stream ToMap(Collectors.toMap)</title>
    <link href="/2021/08/29/Stream%20ToMap(Collectors.toMap)/"/>
    <url>/2021/08/29/Stream%20ToMap(Collectors.toMap)/</url>
    
    <content type="html"><![CDATA[<h1 id="Stream-ToMap-Collectors-toMap"><a href="#Stream-ToMap-Collectors-toMap" class="headerlink" title="Stream ToMap(Collectors.toMap)"></a>Stream ToMap(Collectors.toMap)</h1><h2 id="List-TO-Map"><a href="#List-TO-Map" class="headerlink" title="List TO Map"></a>List TO Map</h2><p>List Stream 转换 Map时向collect()方法中传递Collector对象，对象由Collectors.toMap()方法返回。</p><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;GroupBrandCateBO&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(  <br>      Arrays.asList(  <br>              <span class="hljs-keyword">new</span> GroupBrandCateBO(<span class="hljs-string">&quot;v1&quot;</span>, <span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;b1&quot;</span>),  <br>              <span class="hljs-keyword">new</span> GroupBrandCateBO(<span class="hljs-string">&quot;v1&quot;</span>, <span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;b1&quot;</span>),  <br>              <span class="hljs-keyword">new</span> GroupBrandCateBO(<span class="hljs-string">&quot;v3&quot;</span>, <span class="hljs-string">&quot;g3&quot;</span>, <span class="hljs-string">&quot;b3&quot;</span>)  <br>      )  <br>);  <br>    Map&lt;String, String&gt; map = list.stream().collect(Collectors.toMap(item -&gt; item.getVersion(), item -&gt; item.getGroupCode(), (oldVal, currVal) -&gt; oldVal, LinkedHashMap::<span class="hljs-keyword">new</span>));   <br>       System.out.println(map.getClass());  <br>    Map&lt;String, String&gt; map0 = list.stream().collect(Collectors.toMap(item -&gt; item.getVersion(), item -&gt; item.getGroupCode(), (oldVal, currVal) -&gt; oldVal));  <br>      System.out.println(map0.getClass());  <br>      System.out.println(map0.toString());  <br>    Map&lt;String, String&gt; map1 = list.stream().collect(Collectors.toMap(GroupBrandCateBO::getVersion, GroupBrandCateBO::getGroupCode));  <br>      System.out.println(map1.toString());  <br>  <br></code></pre></div></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当存在Key相同的情况下会出现如下异常：</p><p>Exception in thread “main” java.lang.IllegalStateException: Duplicate key……</p><hr><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>toMap()函数重载：<br>未指定合并函数mergeFunction情况下，传入throwingMerger()返回BinaryOperator对象，当出现key重复时，调用合并函数！<br>未指定Supplier实例情况下，默认生成HashMap实例！</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, U&gt;  <br>    Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; keyMapper,  <br>                                Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; valueMapper) &#123;  <br>    <span class="hljs-keyword">return</span> toMap(keyMapper, valueMapper, throwingMerger(), HashMap::<span class="hljs-keyword">new</span>);  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, U&gt;  <br>    Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; keyMapper,  <br>                                Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; valueMapper,  <br>                                BinaryOperator&lt;U&gt; mergeFunction) &#123;  <br>    <span class="hljs-keyword">return</span> toMap(keyMapper, valueMapper, mergeFunction, HashMap::<span class="hljs-keyword">new</span>);  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, U, M extends Map&lt;K, U&gt;&gt;  <br>    Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; keyMapper,  <br>                            Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; valueMapper,  <br>                            BinaryOperator&lt;U&gt; mergeFunction,  <br>                            Supplier&lt;M&gt; mapSupplier) &#123;  <br>    BiConsumer&lt;M, T&gt; accumulator  <br>            = (map, element) -&gt; map.merge(keyMapper.apply(element),  <br>                                          valueMapper.apply(element), mergeFunction);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CollectorImpl&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);  <br>&#125;  <br>  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">BinaryOperator&lt;T&gt; <span class="hljs-title">throwingMerger</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">return</span> (u,v) -&gt; &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(String.format(<span class="hljs-string">&quot;Duplicate key %s&quot;</span>, u)); &#125;;  <br>&#125;  <br><br></code></pre></div></td></tr></table></figure><hr><p>解决方案：<br>加上：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">(oldVal, currVal) -&gt; currVal) <span class="hljs-comment">// key相同时当前值替换原始值  </span><br>(oldVal, currVal) -&gt; oldVal + currVal <span class="hljs-comment">//key相同时保留原始值和当前值，合并value！！！！！！  </span><br></code></pre></div></td></tr></table></figure><p><em><strong>注：合并的是值value，而不是key！！！</strong></em></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kafka如何保证消息不丢失</title>
    <link href="/2021/08/29/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/"/>
    <url>/2021/08/29/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>kafka对于消息的可靠性保证。作为消息组件，保证消息不丢失，是非常重要的。</p><p>那么kafka是如何保证消息不丢失的呢？</p><hr><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>任何消息组件不丢数据都是在特定场景下一定条件的，<code>kafka</code>要保证消息不丢，有两个核心条件。</p><h3 id="第一-必须是已提交的消息即committed-message"><a href="#第一-必须是已提交的消息即committed-message" class="headerlink" title="第一.必须是已提交的消息即committed message"></a>第一.必须是已提交的消息即committed message</h3><p><code>kafka</code>对于<code>committed message</code>的定义是，生产者提交消息到<code>broker</code>，并等到多个<code>broker</code>确认并返回给生产者已提交的确认信息。而这<code>多个broker</code>是由我们自己来定义的，可以选择只要有一个<code>broker</code>成功保存该消息就算是已提交，也可以是令所有<code>broker</code>都成功保存该消息才算是已提交。不论哪种情况，<code>kafka</code>只对已提交的消息做持久化保证。</p><h3 id="第二-N-个broker中至少有-1-个存活"><a href="#第二-N-个broker中至少有-1-个存活" class="headerlink" title="第二.N 个broker中至少有 1 个存活"></a>第二.N 个<code>broker</code>中至少有 1 个存活</h3><p>虽然<code>kafka</code>集群是分布式的，但也必须保证有足够<code>broker</code>正常工作，才能对消息做持久化做保证。也就是说 <code>kafka</code>不丢消息是有前提条件的，假如你的消息保存在 N 个<code>kafka broker</code>上，那么这个前提条件就是这 N 个<code>broker</code>中至少有 1 个存活。只要此条件成立，<code>kafka</code>就能保证你的这条消息永远不会丢失。</p><h2 id="如何保证消息不丢"><a href="#如何保证消息不丢" class="headerlink" title="如何保证消息不丢"></a>如何保证消息不丢</h2><p>一条消息从产生，到发送到<code>kafka</code>保存，到被取出消费，会有多个场景和流程阶段，很可能会出现丢失情况，上文描述了消息丢失的几种情况，下面简单介绍下如何保证消息不丢失。</p><h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><p><code>Producer</code>端可能会丢失消息。目前<code>Kafka Producer</code>是异步发送消息的，也就是说如果你调用的是<code>producer.send(msg)</code>这个<code>API</code>，那么它通常会立即返回，但此时你不保证消息发送已成功完成。可能会出现：网络抖动，导致消息压根就没有发送到<code>Broker</code>端；或者消息本身不合规导致<code>Broker</code>拒绝接收（比如消息太大了，超过了<code>Broker</code>的限制）。</p><p>使用<code>producer.send(msg, callback)</code>接口就能避免这个问题，根据回调，一旦出现消息提交失败的情况，就可以有针对性地进行处理。如果是因为那些瞬时错误，<code>Producer</code>重试就可以了；如果是消息不合规造成的，那么调整消息格式后再次发送。总之，处理发送失败的责任在<code>Producer</code>端而非<code>Broker</code>端。当然，如果此时<code>broker</code>宕机，那就另当别论。</p><h3 id="1-send-msg-callback"><a href="#1-send-msg-callback" class="headerlink" title="1.send(msg, callback)"></a>1.send(msg, callback)</h3><p>可以从<code>callback</code>回调中得到该条消息的发送结果，并且<code>callback</code>是异步回调，所以在兼具性能的情况下，也对消息具有比较好的掌控。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ProducerRecord&lt;<span class="hljs-keyword">byte</span>[],<span class="hljs-keyword">byte</span>[]&gt; record = <span class="hljs-keyword">new</span> ProducerRecord&lt;<span class="hljs-keyword">byte</span>[],<span class="hljs-keyword">byte</span>[]&gt;(<span class="hljs-string">&quot;the-topic&quot;</span>, key, value);<br>producer.send(myRecord,<br>          <span class="hljs-keyword">new</span> Callback() &#123;<br>              <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompletion</span><span class="hljs-params">(RecordMetadata metadata, Exception e)</span> </span>&#123;<br>                  <span class="hljs-keyword">if</span>(e != <span class="hljs-keyword">null</span>) &#123;<br>                     e.printStackTrace();<br>                  &#125; <span class="hljs-keyword">else</span> &#123;<br>                     System.out.println(<span class="hljs-string">&quot;The offset of the record we just sent is: &quot;</span> + metadata.offset());<br>                  &#125;<br>              &#125;<br>          &#125;);<br></code></pre></div></td></tr></table></figure><p>当我们通过  <code>send(msg, callback)</code> 是不是就意味着消息一定不丢失了呢？<br>答案明显是：不是!</p><p>我们接着上面，<code>send(msg, callback)</code>里面 <code>callback</code>返回的成功，</p><p>到底是不是真的确保消息万无一失了？答案是否定的！</p><h3 id="2-request-required-acks-参数"><a href="#2-request-required-acks-参数" class="headerlink" title="2.request.required.acks 参数"></a>2.request.required.acks 参数</h3><p>还需要通过 <code>request.required.acks </code>参数来设置数据可靠性的级别！</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">props.put(<span class="hljs-string">&quot;acks&quot;</span>, <span class="hljs-string">&quot;all&quot;</span>);<span class="hljs-comment">//或者-1</span><br></code></pre></div></td></tr></table></figure><ul><li>1（默认）：这意味着 producer 在 <code>ISR副本同步队列</code>中的 leader 已成功收到的数据并得到确认后发送下一条 message。如果 leader 宕机了，则会丢失数据。</li><li>0：这意味着 producer 无需等待来自 broker 的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</li><li>-1：producer 需要等待 ISR 中的所有 follower都确认接收到数据后才算一次发送完成，可靠性最高。<strong>但是这样也不能保证数据不丢失</strong>，比如当 ISR 中只有 leader时（ISR 中的成员由于某些情况会增加也会减少，最少就只剩一个 leader），这样就变成了 acks=1 的情况。</li></ul><p>如果要提高数据的可靠性，在设置 <code>request.required.acks=-1</code> 的同时，也要设置最小写入副本数的个数<code>min.insync.replicas</code> 参数 (可以在<code>broker</code>或者 <code>topic</code> 层面进行设置) 的配合，这样才能发挥最大的功效。</p><p><code>min.insync.replicas</code> 这个参数设定 <code>ISR</code> 中的最小副本数是多少，默认值为 1，当且仅当 <code>request.required.acks</code> 参数设置为 -1 时，此参数才生效。</p><p>如果 ISR 中的副本数少于 <code>min.insync.replicas</code> 配置的数量时，客户端会返回异常：org.apache.kafka.common.errors.NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required。</p><h3 id="Broker-端的配置"><a href="#Broker-端的配置" class="headerlink" title="Broker 端的配置"></a>Broker 端的配置</h3><p>其实到这里，生产者端基本已经做好了数据不丢失的大部分准备，但是有些东西是要配合Broker 端一起，才能达到预期的不丢失数据的， 比如上面说到的</p><ul><li><p><code>min.insync.replicas</code> 配置<br>我们上面知道，当 生产者 <code>acks = -1</code> 的时候，写入的副本数就必须 &gt;= <code>min.insync.replicas</code> 数，<br>当达不到这个要求的时候，生产者端会收到一个<code>either NotEnoughReplicas or NotEnoughReplicasAfterAppend</code>的异常。</p><p>所以我们这个<code>min.insync.replicas</code>参数必须不能大于数据冗余备份数 <code>replication.factor</code> 。否则生产者将无法写入任何数据，一般建议 <code>replication.factor</code> 数要大于 <code>min.insync.replicas</code>，比如3个机器的集群，设置 <code>replication.factor</code> = 3，那么设置 <code>min.insync.replicas</code> = 2 即可，这样既保证了数据write的时候有一个副本的冗余，也能保证在一些情况下，某台Broker宕机导致数据无法达到3个副本时，依然可以正常write数据。</p></li><li><p><code>unclean.leader.election.enable</code><br>这里 Broker 端还有一个重要的配置就是 <code>unclean.leader.election.enable = false</code><br>这个配置代表着一些数据落后比较多的 follower，是否能在leader宕机后被选举成新的 leader，如果你设置成 true，很明显，如果这样的follower成为新leader，就会造成最新的一部分数据丢失掉，</p></li></ul><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p><code>Consumer</code>端丢数据的情况稍微复杂些。<code>Consumer</code>”位移“(<code>offset</code>)，表示<code>Consumer</code>当前消费到<code>topic</code>分区的哪个位置。</p><p><code>kafka</code>通过先消费消息，后更新<code>offset</code>，来保证消息不丢失。但是这样可能会出现消息重复的情况，具体如何保证<code>only-once</code>,前文已提到过。</p><p>当我们<code>consumer</code>端开启多线程异步去消费时，情况又会变得复杂一些。此时<code>consumer</code>自动地向前更新<code>offset</code>，假如其中某个线程运行失败了，它负责的消息没有被成功处理，但位移已经被更新了，因此这条消息对于<code>consumer</code>而言实际上是丢失了。</p><p>这里的关键就在自动提交<code>offset</code>，如何真正地确认消息是否真的被消费，再进行更新<code>offset</code>。此问题的解决方式：如果是多线程异步处理消费消息，<code>consumer</code>不要开启自动提交<code>offset</code>，<code>consumer</code>端程序自己来处理<code>offset</code>的提交更新。</p><h2 id="实践配置"><a href="#实践配置" class="headerlink" title="实践配置"></a>实践配置</h2><p>最后分享下<code>kafka</code>无消息丢失配置：</p><ul><li><code>producer</code>端使用<code>producer.send(msg, callback)</code>带有回调的<code>send</code>方法。</li><li>设置<code>acks = all</code>。<code>acks</code>是<code>Producer</code>的一个参数，代表“已提交”消息的定义。如果设置成<code>all</code>，则表明所有<code>Broker</code>都要接收到消息，该消息才算是“已提交”。</li><li>设置<code>retries</code>为一个较大的值。同样是<code>Producer</code>的参数。当出现网络抖动时，消息发送可能会失败，此时配置了<code>retries</code>的<code>Producer</code>能够自动重试发送消息，尽量避免消息丢失。</li><li>设置<code>unclean.leader.election.enable = false</code>。这是<code>Broker</code>端的参数，在<code>kafka</code>版本迭代中社区也多次反复修改过他的默认值，之前比较具有争议。它控制哪些<code>Broker</code>有资格竞选分区的<code>Leader</code>。如果一个<code>Broker</code>落后原先的<code>Leader</code>太多，那么它一旦成为新的<code>Leader</code>，将会导致消息丢失。故一般都要将该参数设置成<code>false</code>！！！</li><li>设置<code>replication.factor &gt;= 3</code>。这也是<code>Broker</code>端的参数。保存多份消息冗余。</li><li>设置<code>min.insync.replicas &gt; 1</code>。<code>Broker</code>端参数，控制消息至少要被写入到多少（一个以上）个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在生产环境中不要使用默认值 1 ！！！确保<code>replication.factor &gt; min.insync.replicas</code>。如果两者相等，那么只要有一个副本离线，整个分区就无法正常工作了。推荐设置成<code>replication.factor = min.insync.replicas + 1</code>。</li><li>确保消息消费完成再提交。<code>Consumer</code>端有个参数<code>enable.auto.commit</code>，最好设置成<code>false</code>，并自己来处理<code>offset</code>的提交更新。</li></ul><hr><p>参考文献</p><ul><li><p><a href="https://kafka.apache.org/documentation/#clientconfig">Apache Kafka</a></p></li><li><p><a href="https://www.zhouyuxin.net/article/137">kafka 如何解决消息队列重复消费 (zhouyuxin.net)</a></p></li><li><p><a href="https://www.infoq.cn/article/depth-interpretation-of-kafka-data-reliability">Kafka数据可靠性深度解读-InfoQ</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1589157">kafka是如何保证消息不丢失的 - 云+社区 - 腾讯云 (tencent.com)</a></p></li><li><p><a href="https://www.jianshu.com/p/4e6f01b4259d">Kafka保证消息不丢失不重复 - 简书 (jianshu.com)</a></p></li><li><p><a href="https://www.jianshu.com/p/68c173e4c549">Kafka ——如何保证消息不会丢失 - 简书 (jianshu.com)</a></p></li><li><p><a href="https://www.cnblogs.com/gaopengpy/p/13516216.html">kafka如何保证消息队列不丢失? - gaopengpy - 博客园 (cnblogs.com)</a></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
