<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅谈Mysql的BTree</title>
    <link href="/2022/04/14/%E6%B5%85%E8%B0%88Mysql%E7%9A%84BTree/"/>
    <url>/2022/04/14/%E6%B5%85%E8%B0%88Mysql%E7%9A%84BTree/</url>
    
    <content type="html"><![CDATA[<h3 id="浅谈MySQL的BTREE索引"><a href="#浅谈MySQL的BTREE索引" class="headerlink" title="浅谈MySQL的BTREE索引"></a>浅谈MySQL的BTREE索引</h3><p>MySQL的MyISAM、InnoDB引擎默认均使用B+树索引（查询时都显示为“BTREE”），本文讨论两个问题：</p><ul><li>为什么MySQL等主流数据库选择B+树的索引结构？</li><li>如何基于索引结构，理解常见的MySQL索引优化思路？</li></ul><h3 id="为什么索引无法全部装入内存"><a href="#为什么索引无法全部装入内存" class="headerlink" title="为什么索引无法全部装入内存"></a>为什么索引无法全部装入内存</h3><p>索引结构的选择基于这样一个性质：<strong>大数据量时，索引无法全部装入内存</strong>。</p><p>为什么索引无法全部装入内存？假设使用树结构组织索引，简单估算一下：</p><ul><li>假设单个索引节点12B，1000w个数据行，unique索引，则叶子节点共占约100MB，整棵树最多200MB。</li><li>假设一行数据占用200B，则数据共占约2G。</li></ul><p>假设索引存储在内存中。也就是说，每在物理盘上保存2G的数据，就要占用200MB的内存，*<code>索引:数据的占用比</code>约为1/10<em>。1/10的占用比算不算大呢？物理盘比内存廉价的多，以一台内存16G硬盘1T的服务器为例，</em>如果要存满1T的硬盘，至少需要100G的内存*，远大于16G。</p><p>考虑到一个表上可能有多个索引、联合索引、数据行占用更小等情况，实际的占用比通常大于1/10，某些时候能达到1/3。<strong>在基于索引的存储架构中，<code>索引:数据的占用比</code>过高，因此，索引无法全部装入内存</strong>。</p><h3 id="其他结构的问题"><a href="#其他结构的问题" class="headerlink" title="其他结构的问题"></a>其他结构的问题</h3><p>由于无法装入内存，则必然依赖磁盘（或SSD）存储。而内存的读写速度是磁盘的成千上万倍（与具体实现有关），因此，核心问题是“<strong>如何减少磁盘读写次数</strong>”。</p><p>首先不考虑页表机制，假设每次读、写都直接穿透到磁盘，那么：</p><ul><li>线性结构：读/写平均O(n)次</li><li>二叉搜索树（BST）：读/写平均O(log2(n))次；如果树不平衡，则最差读/写O(n)次</li><li>自平衡二叉搜索树（AVL）：在BST的基础上加入了自平衡算法，读/写最大O(log2(n))次</li><li>红黑树（RBT）：另一种自平衡的查找树，读/写最大O(log2(n))次</li></ul><p>BST、AVL、RBT很好的将读写次数从O(n)优化到O(log2(n))；其中，AVL和RBT都比BST多了自平衡的功能，将读写次数降到最大O(log2(n))。</p><p>假设使用自增主键，则主键本身是有序的，树结构的读写次数能够优化到树高，树高越低读写次数越少；自平衡保证了树结构的稳定。如果想进一步优化，可以引入B树和B+树。</p><h3 id="B树解决了什么问题"><a href="#B树解决了什么问题" class="headerlink" title="B树解决了什么问题"></a>B树解决了什么问题</h3><blockquote><p>很多文章将B树误称为B-（减）树，这可能是对其英文名“B-Tree”的误解（更有甚者，将B树称为二叉树或二叉搜索树）。特别是与B+树一起讲的时候。想当然的认为有B+（加）树就有B-（减）树，实际上B+树的英文名是“B+-Tree”。</p></blockquote><p>如果抛开维护操作，那么B树就像一棵“m叉搜索树”（m是子树的最大个数），时间复杂度为O(logm(n))。然而，B树设计了一种高效简单的维护操作，使B树的深度维持在约log(ceil(m/2))(n)~logm(n)之间，<strong>大大降低树高</strong>。</p><p><img src="https://raw.githubusercontent.com/monkeysayhi/HexoBlogOnGithub/master/qiniu/static/images/%E6%B5%85%E8%B0%88MySQL%E7%9A%84B%E6%A0%91%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/B%E6%A0%91.png" srcset="/img/loading.gif" lazyload alt="B树"></p><blockquote><p>再次强调：</p><p>不要纠结于时间复杂度，与单纯的算法不同，磁盘IO次数才是更大的影响因素。读者可以推导看看，B树与AVL的时间复杂度是相同的，但由于B树的层数少，磁盘IO次数少，实践中B树的性能要优于AVL等二叉树。</p></blockquote><p>同二叉搜索树类似，每个节点存储了多个key和子树，子树与key按顺序排列。</p><p>页表的目的是扩展内存+加速磁盘读写。一个页（Page）通常4K（等于磁盘数据块block的大小，见inode与block的分析），从磁盘读写的角度出发，操作系统每次以页为单位将内容从磁盘加载到内存（以摊分寻道成本），修改页后，再择期将该页写回磁盘。考虑到页表的良好性质，可以使每个节点的大小约等于一个页（使m非常大），这每次加载的一个页就能完整覆盖一个节点，以便选择下一层子树；对子树同理。对于页表来说，AVL（或RBT）相当于1个key+2个子树的B树，由于逻辑上相邻的节点，物理上通常不相邻，因此，读入一个4k页，页面内绝大部分空间都将是无效数据。</p><p>假设key、子树节点指针均占用4B，则B树节点最大<code>m * (4 + 4) = 8m B</code>；页面大小4KB。则<code>m = 4 * 1024 / 8 = 512</code>，一个512叉的B树，1000w的数据，深度最大 <code>log(512/2)(10^7) = 3.02 ~= 4</code>。对比二叉树如AVL的深度为<code>log(2)(10^7) = 23.25 ~= 24</code>，相差了5倍以上。震惊！B树索引深度竟然如此！</p><p>另外，B树<strong>对局部性原理非常友好</strong>。如果key比较小（比如上面4B的自增key），则除了页表的加成，缓存还能进一步预读加速。美滋滋~</p><h3 id="B-树解决了什么问题"><a href="#B-树解决了什么问题" class="headerlink" title="B+树解决了什么问题"></a>B+树解决了什么问题</h3><h3 id="B树的剩余问题"><a href="#B树的剩余问题" class="headerlink" title="B树的剩余问题"></a>B树的剩余问题</h3><p>然而，如果要实际应用到数据库的索引中，B树还有一些问题：</p><ol><li>未定位数据行</li><li>无法处理范围查询</li></ol><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>数据表的记录有多个字段，仅仅定位到主键是不够的，还需要定位到数据行。有3个方案解决：</p><ol><li>直接将key对应的数据行（可能对应多行）存储在节点中。</li><li>数据行单独存储；节点中增加一个字段，定位key对应数据行的位置。</li><li>修改key与子树的判断逻辑，使子树大于等于上一key小于下一key，最终所有访问都将落于叶子节点；叶子节点中直接存储数据行或数据行的位置。</li></ol><p>方案1中，数据行通常非常大，存储数据行将减少页面中的子树个数，m减小树高增大。假设数据行占用200B，可忽略组织B树的指针，则新的<code>m = 4 * 1024 / 200 = 20.48 ~= 21</code>，深度最大 <code>log(21/2)(10^7) ~= 7</code>。增加了一倍以上的IO，不考虑。</p><p>方案2中，节点增加了一个字段。假设是4B的指针，则新的<code>m = 4 * 1024 / 12 = 341.33 ~= 341</code>，深度最大 <code>log(341/2)(10^7) = 3.14 ~= 4</code>。与3差别不大，可以考虑。</p><p>方案3的节点m与深度不变，但时间复杂度变为稳定的O(logm(n))。考虑。</p><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>实际业务中，范围查询的频率非常高，B树只能定位到一个索引位置（可能对应多行），很难处理范围查询。给出2种方案：</p><ol><li>不改动：查询的时候先查到左界，再查到右界，然后DFS（或BFS）遍历左界、右界之间的节点。</li><li>在“问题1-方案3”的基础上，由于所有数据行都存储在叶子节点，B树的叶子节点本身也是有序的，可以增加一个指针，指向当前叶子节点按主键顺序的下一叶子节点；查询时先查到左界，再查到右界，然后从左界到有界线性遍历。</li></ol><p>乍一看感觉方案1比方案2好——时间复杂度和常数项都一样，方案1还不需要改动。但是别忘了局部性原理，不管节点中存储的是数据行还是数据行位置，方案2的好处在于，叶子节点连续存储，对页表和缓存友好。而方案1则面临节点逻辑相邻、物理分离的缺点。</p><h3 id="引出B-树"><a href="#引出B-树" class="headerlink" title="引出B+树"></a>引出B+树</h3><p>综上，问题1的方案2与问题2的方案1可整合为一种方案（基于B树的索引），问题1的方案3与问题2的方案2可整合为一种（基于B+树的索引）。实际上，数据库、文件系统有些采用了B树，有些采用B+树。</p><p>包括MySQL在内的主流数据库多选择了B+树。即：</p><p><img src="https://raw.githubusercontent.com/monkeysayhi/HexoBlogOnGithub/master/qiniu/static/images/%E6%B5%85%E8%B0%88MySQL%E7%9A%84B%E6%A0%91%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/B+%E6%A0%91.png" srcset="/img/loading.gif" lazyload alt="B+树"></p><p>主要变动如上所述：</p><ul><li>修改key与子树的组织逻辑，将索引访问都落到叶子节点</li><li>按顺序将叶子节点串起来（方便范围查询）</li></ul><h3 id="B树和B-树的增、删、查过程"><a href="#B树和B-树的增、删、查过程" class="headerlink" title="B树和B+树的增、删、查过程"></a>B树和B+树的增、删、查过程</h3><p>B树的增删过程暂时可参考<a href="http://blog.csdn.net/v_JULY_v/article/details/6530142/">从B树、B+树、B*树谈到R 树</a>的“6、B树的插入、删除操作”小节，B+树的增删同理。此处暂不赘述。</p><h3 id="Mysql索引优化"><a href="#Mysql索引优化" class="headerlink" title="Mysql索引优化"></a>Mysql索引优化</h3><p>根据B+树的性质，很容易理解各种常见的MySQL索引优化思路。</p><blockquote><p>暂不考虑不同引擎之间的区别。</p></blockquote><h4 id="优先使用自增key作为主键"><a href="#优先使用自增key作为主键" class="headerlink" title="优先使用自增key作为主键"></a>优先使用自增key作为主键</h4><p>前面的分析中，假设用4B的自增key作为索引，则m可达到512，层高仅有3。使用自增的key有两个好处：</p><ol><li>自增key一般为int等整数型，key比较紧凑，这样m可以非常大，而且索引占用空间小。最极端的例子，如果使用50B的varchar（包括长度），那么<code>m = 4 * 1024 / 54m = 75.85 ~= 76</code>，深度最大 <code>log(76/2)(10^7) = 4.43 ~= 5</code>，再加上cache缺失、字符串比较的成本，时间成本增加较大。同时，key由4B增长到50B，整棵索引树的空间占用增长也是极为恐怖的（如果二级索引使用主键定位数据行，则空间增长更加严重）。</li><li>自增的性质使得新数据行的插入请求必然落到索引树的最右侧，发生节点分裂的频率较低，理想情况下，索引树可以达到“满”的状态。索引树满，一方面层高更低，一方面删除节点时发生节点合并的频率也较低。</li></ol><h4 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h4><p>索引可以简单如一个列(a)，也可以复杂如多个列(a, b, c, d)，即<code>联合索引</code>。如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询(&gt;、&lt;、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。因此，列的排列顺序决定了可命中索引的列数。</p><p>如有索引(a, b, c, d)，查询条件<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，则会在每个节点依次命中a、b、c，无法命中d。也就是最左前缀匹配原则。</p><h4 id="、in自动优化顺序"><a href="#、in自动优化顺序" class="headerlink" title="=、in自动优化顺序"></a>=、in自动优化顺序</h4><p>不需要考虑=、in等的顺序，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。</p><p>如有索引(a, b, c, d)，查询条件<code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code>与<code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code>等顺序都是可以的，MySQL会自动优化为<code>a = 1 and b = 2 and c &gt; 3 and d &lt; 4</code>，依次命中a、b、c。</p><h4 id="索引列不能参与计算"><a href="#索引列不能参与计算" class="headerlink" title="索引列不能参与计算"></a>索引列不能参与计算</h4><p>有索引列参与计算的查询条件对索引不友好（甚至无法使用索引），如<code>from_unixtime(create_time) = &#39;2014-05-29&#39;</code>。</p><p>原因很简单，如何在节点中查找到对应key？如果线性扫描，则每次都需要重新计算，成本太高；如果二分查找，则需要针对from_unixtime方法确定大小关系。</p><p>因此，索引列不能参与计算。上述<code>from_unixtime(create_time) = &#39;2014-05-29&#39;</code>语句应该写成<code>create_time = unix_timestamp(&#39;2014-05-29&#39;)</code>。</p><h4 id="能扩展就不要新建索引"><a href="#能扩展就不要新建索引" class="headerlink" title="能扩展就不要新建索引"></a>能扩展就不要新建索引</h4><p>如果已有索引(a)，想建立索引(a, b)，尽量选择修改索引(a)为索引(a, b)。</p><p>新建索引的成本很容易理解。而基于索引(a)修改为索引(a, b)的话，MySQL可以直接在索引a的B+树上，经过分裂、合并等修改为索引(a, b)。</p><h4 id="不需要建立前缀有包含关系的索引"><a href="#不需要建立前缀有包含关系的索引" class="headerlink" title="不需要建立前缀有包含关系的索引"></a>不需要建立前缀有包含关系的索引</h4><p>如果已有索引(a, b)，则不需要再建立索引(a)，但是如果有必要，则仍然需考虑建立索引(b)。</p><h4 id="选择区分度高的列作索引"><a href="#选择区分度高的列作索引" class="headerlink" title="选择区分度高的列作索引"></a>选择区分度高的列作索引</h4><p>很容易理解。如，用性别作索引，那么索引仅能将1000w行数据划分为两部分（如500w男，500w女），索引几乎无效。</p><p><code>区分度</code>的公式是<code>count(distinct &lt;col&gt;) / count(*)</code>，表示字段不重复的比例，比例越大区分度越好。唯一键的区分度是1，而一些状态、性别字段可能在大数据面前的区分度趋近于0。</p><blockquote><p>这个值很难确定，一般需要join的字段要求是0.1以上，即平均1条扫描10条记录。</p></blockquote><hr><p>参考：</p><ul><li><p><a href="https://blog.csdn.net/ctflq/article/details/124119436">MySQL索引优化及性能调优</a></p></li><li><p><a href="http://blog.csdn.net/v_JULY_v/article/details/6530142/">从B树、B+树、B*树谈到R 树</a></p></li><li><p><a href="https://tech.meituan.com/">美团技术团队 (meituan.com)</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池ThreadPoolExecutor分析</title>
    <link href="/2022/03/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%88%86%E6%9E%90/"/>
    <url>/2022/03/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="线程池生命周期及状态"><a href="#线程池生命周期及状态" class="headerlink" title="线程池生命周期及状态"></a>线程池生命周期及状态</h3><blockquote><p>RUNNING: 接收新任务，也处理队列任务</p></blockquote><blockquote><p>SHUTDOWN: 不接收新任务，但是处理队列任务</p></blockquote><blockquote><p>STOP:   不接收新任务，不处理队列任务并且中断正在进行的任务</p></blockquote><blockquote><p>TIDYING: 所有任务都终止，workerCount为零，线程状态转为TIDYING，将运行terminated()方法</p></blockquote><blockquote><p>TERMINATED: terminated() 方法执行完毕</p></blockquote><h3 id="任务执行流程"><a href="#任务执行流程" class="headerlink" title="任务执行流程"></a>任务执行流程</h3><blockquote><p>execute(Runnable command) –&gt; addWorker(Runnable firstTask,boolean core) –&gt;runWorker(Worker w)</p></blockquote><ul><li><p>线程池的工作线程由Worker类实现，通过ReentrantLock锁，把worker实例插入到HashSet中,并启动Worker中的线程。</p></li><li><p>而Worker类的构造方法实现可以看出：threadFactory创建线程thread时，将worker实例本身this作为参数传入，执行start()时，本质是调用Worker的run()方法，run() 又调用了外部的runWorker()方法。</p></li><li><p>firstTask执行完成之后，通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源</p></li></ul><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><ol><li><p>线程池是什么时候创建线程的？</p></li><li><p>任务runnable task是先放到core到maxThread之间的线程，还是先放到队列？</p></li><li><p>队列中的任务是什么时候取出来的？</p></li><li><p>什么时候会触发reject策略？</p></li><li><p>core到maxThread之间的线程什么时候会die?</p></li><li><p>task抛出异常，线程池中这个work thread还能运行其他任务吗?</p></li></ol><h2 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h2><p><a href="https://gitee.com/Cai_Programmer/pic-go/raw/master/9e743837-29f4-4510-bcce-44542ad8f338.jpg"><img src="https://gitee.com/Cai_Programmer/pic-go/raw/master/9e743837-29f4-4510-bcce-44542ad8f338.jpg" srcset="/img/loading.gif" lazyload></a></p><p>创建线程池都会调用核心构造方法<code>ThreadPoolExecutor</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                              TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>             Executors.defaultThreadFactory(), defaultHandler);<br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>corePoolSize:核心线程最大数量，通俗点来讲就是，线程池中常驻线程的最大数量<br>maximumPoolSize:线程池中运行最大线程数(包括核心线程和非核心线程)<br>keepAliveTime:线程池中空闲线程（仅适用于非核心线程）所能存活的最长时间<br>unit:存活时间单位，与keepAliveTime搭配使用<br>workQueue：存放任务的阻塞队列<br>handler:线程池饱和策略</p></blockquote><p>在new ThreadPoolExecutor()创建线程池时，Thread对象并没有初始化. 这里仅仅指定了初始参数；</p><p>###线程是在什么时候创建的呢？<br>当执行execute时，更具当前条件（核心线程数与队列情况）判断，创建work线程。<br>###执行execute</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>       <span class="hljs-keyword">int</span> c = ctl.get();<br>       <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<span class="hljs-comment">//当前线程数小于corePoolSize, 则创建新的核心worker对象</span><br>           <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>               <span class="hljs-keyword">return</span>;<br>           c = ctl.get();<br>       &#125;<br>       <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="hljs-comment">//如果当前线程数大于corePoolSize, 并偿试放入队列 workQueue.offer(command) , 放入成功后等待线程池调度</span><br>           <span class="hljs-keyword">int</span> recheck = ctl.get();<br>           <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>               reject(command);<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>               addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<span class="hljs-comment">//偿试放入队列 workQueue.offer(command) 失败， 增加一个非core的线程</span><br>           reject(command);<br>   &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>第一个if， 判断如果当前线程数小于corePoolSize, 则创建新的核心worker对象（Worker中指向Thread对象，保持引用，保证不会被GC回收）</p></blockquote><blockquote><p>第二个if,   判断如果当前线程数大于corePoolSize, 并偿试放入队列 workQueue.offer(command) , 放入成功后等待线程池调度【见后面的getTask()】<br>第三个if,  偿试放入队列 workQueue.offer(command) 失败， 增加一个非core的线程</p></blockquote><hr><p>###增加任务addWorker</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        w = <span class="hljs-keyword">new</span> Worker(firstTask);<span class="hljs-comment">//此处new work()创建线程</span><br>        <span class="hljs-keyword">final</span> Thread t = w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    workers.add(w);<span class="hljs-comment">//线程池this的worker容器，保持对线程的引用</span><br>                    <span class="hljs-keyword">int</span> s = workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();<span class="hljs-comment">//处理结束后，启动线程</span><br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>###new work()创建线程<br>work构造方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">      Worker(Runnable firstTask) &#123;<br>          setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>          <span class="hljs-keyword">this</span>.firstTask = firstTask;<br>          <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//创建线程</span><br>      &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>          runWorker(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//线程创建后，运行</span><br>      &#125;<br></code></pre></div></td></tr></table></figure><h3 id="runWorker-启动线程"><a href="#runWorker-启动线程" class="headerlink" title="runWorker 启动线程"></a>runWorker 启动线程</h3><p>线程启动后，又做了那些事情呢？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>      Thread wt = Thread.currentThread();<br>      Runnable task = w.firstTask;<br>      w.firstTask = <span class="hljs-keyword">null</span>;<br>      w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>      <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//通过getTask()获取任务</span><br>              w.lock();<br>              <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>              <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>              <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>              <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>              <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                   (Thread.interrupted() &amp;&amp;<br>                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                  !wt.isInterrupted())<br>                  wt.interrupt();<br>              <span class="hljs-keyword">try</span> &#123;<br>                  beforeExecute(wt, task);<br>                  Throwable thrown = <span class="hljs-keyword">null</span>;<br>                  <span class="hljs-keyword">try</span> &#123;<br>                      task.run();<br>                  &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                      thrown = x; <span class="hljs-keyword">throw</span> x;<br>                  &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                      thrown = x; <span class="hljs-keyword">throw</span> x;<br>                  &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                      thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                  &#125; <span class="hljs-keyword">finally</span> &#123;<br>                      afterExecute(task, thrown);<span class="hljs-comment">//执行结束后的清理工作</span><br>                  &#125;<br>              &#125; <span class="hljs-keyword">finally</span> &#123;<br>                  task = <span class="hljs-keyword">null</span>;<br>                  w.completedTasks++;<br>                  w.unlock();<br>              &#125;<br>          &#125;<br>          completedAbruptly = <span class="hljs-keyword">false</span>;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//如果抛出异常后执行以下方法</span><br>          processWorkerExit(w, completedAbruptly);<br>      &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>没抛异常时，会一直在while（task !=null || (task = getTask())!=null）中执行；<br>如果有异常时，再看一下processWorkerExit()</p></blockquote><h3 id="processWorkerExit-异常处理"><a href="#processWorkerExit-异常处理" class="headerlink" title="processWorkerExit 异常处理"></a>processWorkerExit 异常处理</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        decrementWorkerCount();<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        completedTaskCount += w.completedTasks;<br>        workers.remove(w);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    tryTerminate();<br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>            <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>从此可以看出有异常时 <strong>旧的worker会被删除（GC回收）</strong>，再创建新的Worker， 即有异常时 <strong>旧worker不可能再执行新的任务</strong></p></blockquote><p>##结论</p><p>###执行流程判断<br>当提交一个新任务，线程池的处理流程如下：</p><ul><li>判断线程池中核心线程数是否已达阈值corePoolSize,若否，则创建一个新核心线程执行任务</li><li>若核心线程数已达阈值corePoolSize,判断阻塞队列workQueue是否已满，若未满，则将新任务添加进阻塞队列</li><li>若满，再判断，线程池中线程数是否达到阈值maximumPoolSize,若否，则新建一个非核心线程执行任务。若达到阈值，则执行线程池饱和策略。</li></ul><p>线程池饱和策略分为一下几种：</p><ul><li>AbortPolicy:直接抛出一个异常，默认策略</li><li>DiscardPolicy: 直接丢弃任务</li><li>DiscardOldestPolicy:抛弃下一个将要被执行的任务(最旧任务)</li><li>CallerRunsPolicy:主线程中执行任务</li></ul><p>流程：<br><a href="https://gitee.com/Cai_Programmer/pic-go/raw/master/2f0a2292-8c67-4d5a-9d36-c95570607447.jpg"><img src="https://gitee.com/Cai_Programmer/pic-go/raw/master/2f0a2292-8c67-4d5a-9d36-c95570607447.jpg" srcset="/img/loading.gif" lazyload></a></p><hr><h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><blockquote><p>Q. 线程池是什么时候创建线程的？<br>A.任务提交的时候</p></blockquote><blockquote><p>Q.任务runnable task是先放到core到maxThread之间的线程，还是先放到队列？<br>A.先放队列!!!</p></blockquote><blockquote><p>Q. 队列中的任务是什么时候取出来的？<br>A. worker中 runWorker() 一个任务完成后，会取下一个任务</p></blockquote><blockquote><p>Q. 什么时候会触发reject策略？<br>A.队列满并且maxthread也满了， 还有新任务，默认策略是reject</p></blockquote><blockquote><p>Q. core到maxThread之间的线程什么时候会die?<br>A.  没有任务时，或者抛异常时。core线程也会die的，core到maxThread之间的线程有可能会晋升到core线程区间，core max只是个计数，线程并不是创建后就固定在一个区间了</p></blockquote><blockquote><p>Q. task抛出异常，线程池中这个work thread还能运行其他任务吗?<br>A. 不能。 但是会创建新的线程, 新线程可以运行其他task。</p></blockquote><p>参阅：</p><blockquote><ul><li><a href="https://links.jianshu.com/go?to=https://blog.csdn.net/programmer_at/article/details/79799267">Java线程池实现原理与源码解析(jdk1.8)</a></li><li><a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/yszzu/p/10122658.html">线程池ThreadPoolExecutor分析: 线程池是什么时候创建线程的，队列中的任务是什么时候取出来的？</a></li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 表按时间分区（内附脚本）</title>
    <link href="/2022/03/17/Mysql-%E8%A1%A8%E6%8C%89%E6%97%B6%E9%97%B4%E5%88%86%E5%8C%BA%EF%BC%88%E5%86%85%E9%99%84%E8%84%9A%E6%9C%AC%EF%BC%89/"/>
    <url>/2022/03/17/Mysql-%E8%A1%A8%E6%8C%89%E6%97%B6%E9%97%B4%E5%88%86%E5%8C%BA%EF%BC%88%E5%86%85%E9%99%84%E8%84%9A%E6%9C%AC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="mysql表分区的几种方式"><a href="#mysql表分区的几种方式" class="headerlink" title="mysql表分区的几种方式"></a>mysql表分区的几种方式</h3><p>参阅：<a href="https://www.cnblogs.com/mliudong/p/3625522.html" title="MySQL表的四种分区类型">MySQL表的四种分区类型</a></p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/73aa05cccd0241e3b0b1a0ba0b36b93a.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>常用的按时间分区可以按照年、月、日等条件用来分区，因为是按时间条件分区所以选用RANGE分区方式。</p><h4 id="分区的条件判断："><a href="#分区的条件判断：" class="headerlink" title="分区的条件判断："></a>分区的条件判断：</h4><ul><li>LESS THAN：如果是数值就是小于等于，时间则是小于。</li><li>LESS THAN MAX:不等于。</li><li>IN:包含于某某区间。</li></ul><h4 id="按实际分区的时间函数选用："><a href="#按实际分区的时间函数选用：" class="headerlink" title="按实际分区的时间函数选用："></a>按实际分区的时间函数选用：</h4><ul><li>按日分区切分时的条件可以用day()、to_days()时间函数，需要注意的是必须是返回值是整形的。</li><li>按月分区采用month()时间函数;</li><li>其他条件分区的时间函数：可查看：<a href="https://blog.csdn.net/qq_36216193/article/details/90404527">SQL语句：日期函数汇总</a></li></ul><p>其中按时间字段create_date按天分区，首先需要把date字段改成主键，后添加分区切分规则</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> js_sys_log <br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (id, create_date);  <span class="hljs-comment">--之前id是主键，所以这里第2主键为联合主键</span><br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>  js_sys_log  <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (create_date);<br></code></pre></div></td></tr></table></figure><p>为了便于管理分区名通常以“p时间”来命名。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">示例一：<br>    <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>  js_sys_log  <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> (to_days(create_date)) (<br>        <span class="hljs-keyword">PARTITION</span>  p20181101  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181101&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181102  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181102&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181103  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181103&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181104  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181104&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181105  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181105&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181106  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181106&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181107  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181107&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181108  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181108&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181109  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181109&#x27;</span>)),<br>        <span class="hljs-keyword">PARTITION</span>  p20181110  <span class="hljs-keyword">VALUES</span> LESS THAN (to_days(<span class="hljs-string">&#x27;20181110&#x27;</span>))，<br>        <span class="hljs-keyword">PARTITION</span>  p_other  <span class="hljs-keyword">VALUES</span> LESS THAN MAXVALUE );<br>    );<br></code></pre></div></td></tr></table></figure><h4 id="后期添加分区"><a href="#后期添加分区" class="headerlink" title="后期添加分区"></a>后期添加分区</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">示例二：<br>    <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>  js_sys_log  <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PARTITION</span> (<span class="hljs-keyword">PARTITION</span>  p20181111 <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DAYS (<span class="hljs-string">&#x27;2018-11-11&#x27;</span>)));<br></code></pre></div></td></tr></table></figure><h4 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">示例三：<br>    <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>  js_sys_log  <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PARTITION</span> p20181101;<br></code></pre></div></td></tr></table></figure><h4 id="查询MySQL的系统字典库得知所有的分区详情信息"><a href="#查询MySQL的系统字典库得知所有的分区详情信息" class="headerlink" title="查询MySQL的系统字典库得知所有的分区详情信息"></a>查询MySQL的系统字典库得知所有的分区详情信息</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">示例四：<br>    <span class="hljs-keyword">SELECT</span>  <span class="hljs-operator">*</span>  <span class="hljs-keyword">FROM</span>  information_schema. PARTITIONS  t  <span class="hljs-keyword">WHERE</span> t.PARTITION_NAME <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br></code></pre></div></td></tr></table></figure><h3 id="在分区创建后可以通过过程和事件控制自动增加表分区"><a href="#在分区创建后可以通过过程和事件控制自动增加表分区" class="headerlink" title="在分区创建后可以通过过程和事件控制自动增加表分区"></a>在分区创建后可以通过过程和事件控制自动增加表分区</h3><p>1.查看是否开启事件</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> &quot;event_scheduler&quot;;<br></code></pre></div></td></tr></table></figure><p>2.开启事件（本次设置中有效）</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> event_scheduler <span class="hljs-operator">=</span> <span class="hljs-keyword">on</span>;    <br>或<br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> event_scheduler <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>3.长期有效（配置文件设置）</p><p>my.cnf中设置 event_scheduler = on; 重启服务即可。</p><p>4.设置分区脚本</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">use test;<br>DELIMITER <span class="hljs-operator">||</span><br><span class="hljs-comment">-- 删除存储过程</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">procedure</span> if <span class="hljs-keyword">exists</span> 事件名称 <span class="hljs-operator">||</span><br><span class="hljs-comment">-- 注意：使用该存储过程必须保证相应数据库表中至少有一个手动分区</span><br><span class="hljs-comment">-- 创建存储过程[通过数据库名和对应表名]-建多少个分区，分区时间间隔为多少</span><br><span class="hljs-comment">-- databasename：创建分区的数据库</span><br><span class="hljs-comment">-- tablename：创建分区的表的名称</span><br><span class="hljs-comment">-- partition_number：一次创建多少个分区</span><br><span class="hljs-comment">-- partitiontype：分区类型[0按天分区，1按月分区，2按年分区]</span><br><span class="hljs-comment">-- gaps：分区间隔，如果分区类型为0则表示每个分区的间隔为 gaps天；</span><br><span class="hljs-comment">-- 如果分区类型为1则表示每个分区的间隔为 gaps月</span><br><span class="hljs-comment">-- 如果分区类型为2则表示每个分区的间隔为 gaps年</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> 事件名称 (<span class="hljs-keyword">in</span> databasename <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci,<span class="hljs-keyword">in</span> tablename <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci, <span class="hljs-keyword">in</span> partition_number <span class="hljs-type">int</span>, <span class="hljs-keyword">in</span> partitiontype <span class="hljs-type">int</span>, <span class="hljs-keyword">in</span> gaps <span class="hljs-type">int</span>)<br>L_END:<br><span class="hljs-keyword">begin</span>     <br>    <span class="hljs-keyword">declare</span> max_partition_description <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">declare</span> p_name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;       <br>    <span class="hljs-keyword">declare</span> p_description <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;   <br>    <span class="hljs-keyword">declare</span> isexist_partition <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>; <br> <span class="hljs-keyword">declare</span> i <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br>  <br> <span class="hljs-comment">-- 查看对应数据库对应表是否已经有手动分区[自动分区前提是必须有手动分区]</span><br>    <span class="hljs-keyword">select</span> partition_name <span class="hljs-keyword">into</span> isexist_partition <span class="hljs-keyword">from</span> information_schema.partitions <span class="hljs-keyword">where</span> table_schema <span class="hljs-operator">=</span> databasename  <span class="hljs-keyword">and</span> table_name <span class="hljs-operator">=</span> tablename limit <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">-- 如果不存在则打印错误并退出存储过程</span><br>    if isexist_partition <span class="hljs-operator">&lt;=&gt;</span> &quot;&quot; <span class="hljs-keyword">then</span><br>       <span class="hljs-keyword">select</span> &quot;partition table not is exist&quot; <span class="hljs-keyword">as</span> &quot;ERROR&quot;;<br>       leave L_END;<br>    <span class="hljs-keyword">end</span> if;<br> <br>    <span class="hljs-comment">-- 获取最大[降序获取]的分区描述[值]</span><br>    <span class="hljs-keyword">select</span> partition_description <span class="hljs-keyword">into</span> max_partition_description  <span class="hljs-keyword">from</span> information_schema.partitions <span class="hljs-keyword">where</span> table_schema <span class="hljs-operator">=</span> databasename  <span class="hljs-keyword">and</span> table_name <span class="hljs-operator">=</span> tablename <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> partition_description <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1</span>;<br>   <br>    <span class="hljs-comment">-- 如果最大分区没有,说明没有手动分区,则无法创建自动分区</span><br>    if max_partition_description <span class="hljs-operator">&lt;=&gt;</span> &quot;&quot; <span class="hljs-keyword">then</span><br>       <span class="hljs-keyword">select</span> &quot;partition table is error&quot; <span class="hljs-keyword">as</span> &quot;ERROR&quot;;<br>       leave L_END;<br>    <span class="hljs-keyword">end</span> if;<br> <br>    <span class="hljs-comment">-- 替换前后的单引号[&#x27;&#x27;两个引号表示一个单引号的转义]</span><br>    <span class="hljs-comment">-- set max_partition_description = REPLACE(max_partition_description, &#x27;&#x27;&#x27;&#x27;, &#x27;&#x27;);</span><br>    <span class="hljs-comment">-- 或使用如下语句</span><br>    <span class="hljs-keyword">set</span> max_partition_description <span class="hljs-operator">=</span> REPLACE(max_partition_description<span class="hljs-number">-1</span>, <span class="hljs-string">&#x27;\&#x27;&#x27;, &#x27;&#x27;);</span><br><span class="hljs-string"> </span><br><span class="hljs-string">    -- 自动创建number个分区</span><br><span class="hljs-string">    while (i &lt;= partition_number) do</span><br><span class="hljs-string">                 if (partitiontype = 0) then</span><br><span class="hljs-string">                     -- 每个分区按天递增,递增gaps天</span><br><span class="hljs-string">                     set p_description = DATE_ADD(FROM_DAYS(max_partition_description), interval i*gaps day); </span><br><span class="hljs-string">                 elseif (partitiontype = 1) then</span><br><span class="hljs-string">                     -- 每个分区按月递增,递增gaps月</span><br><span class="hljs-string">                     set p_description = DATE_ADD(FROM_DAYS(max_partition_description), interval i*gaps month); </span><br><span class="hljs-string">                 else </span><br><span class="hljs-string">                     -- 每个分区按年递增,递增gaps年</span><br><span class="hljs-string">                     set p_description = DATE_ADD(FROM_DAYS(max_partition_description), interval i*gaps year);</span><br><span class="hljs-string">                 end if;</span><br><span class="hljs-string">                 -- 删除空格</span><br><span class="hljs-string">                 set p_name = REPLACE(p_description, &#x27;</span> <span class="hljs-string">&#x27;, &#x27;&#x27;);</span><br><span class="hljs-string">                 -- 例如10.20的记录实际是less than 10.21</span><br><span class="hljs-string">                 set p_description = DATE_ADD(p_description, interval 1 day); </span><br><span class="hljs-string">                 -- 如果有横杆替换为空</span><br><span class="hljs-string">          set p_name = REPLACE(p_name, &#x27;</span><span class="hljs-operator">-</span><span class="hljs-string">&#x27;, &#x27;&#x27;);</span><br><span class="hljs-string">                 -- 删除时间冒号</span><br><span class="hljs-string">                 set p_name = REPLACE(p_name, &#x27;</span>:<span class="hljs-string">&#x27;, &#x27;&#x27;);</span><br><span class="hljs-string">                 -- alter table tablename add partition ( partition pname values less than (&#x27;</span><span class="hljs-number">2019</span><span class="hljs-number">-05</span><span class="hljs-number">-22</span> <span class="hljs-number">23</span>:<span class="hljs-number">59</span>:<span class="hljs-number">59</span><span class="hljs-string">&#x27;) );</span><br><span class="hljs-string">          set @sql=CONCAT(&#x27;</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">&#x27;, tablename ,&#x27;</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PARTITION</span> ( <span class="hljs-keyword">PARTITION</span> p<span class="hljs-string">&#x27;, p_name ,&#x27;</span> <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DAYS(\<span class="hljs-string">&#x27;&#x27;</span>, p_description ,<span class="hljs-string">&#x27;\&#x27;</span>)))<span class="hljs-string">&#x27;);</span><br><span class="hljs-string">                 -- set @sql=CONCAT(&#x27;</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">&#x27;, tablename ,&#x27;</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PARTITION</span> ( <span class="hljs-keyword">PARTITION</span> p<span class="hljs-string">&#x27;, p_name ,&#x27;</span> <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DAYS(\<span class="hljs-string">&#x27;&#x27;</span>, p_description ,<span class="hljs-string">&#x27;\&#x27;</span>)))<span class="hljs-string">&#x27;);</span><br><span class="hljs-string">                 -- 打印sql变量</span><br><span class="hljs-string">          -- select @sql;</span><br><span class="hljs-string">                 -- 准备sql语句</span><br><span class="hljs-string">          PREPARE stmt from @sql;</span><br><span class="hljs-string">                 -- 执行sql语句</span><br><span class="hljs-string">          EXECUTE stmt;</span><br><span class="hljs-string">                 -- 释放资源</span><br><span class="hljs-string">          DEALLOCATE PREPARE stmt;</span><br><span class="hljs-string">                 -- 递增变量</span><br><span class="hljs-string">          set i = (i + 1) ;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">    end while;          </span><br><span class="hljs-string">end ||</span><br><span class="hljs-string">-- 恢复语句中断符</span><br><span class="hljs-string">DELIMITER ;</span><br></code></pre></div></td></tr></table></figure><p>5.事件处理(on schedule every 1 day)</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">DELIMITER <span class="hljs-operator">||</span><br><span class="hljs-keyword">drop</span> event if <span class="hljs-keyword">exists</span> 事件名称 <span class="hljs-operator">||</span><br><span class="hljs-keyword">create</span> event 事件名称<br><span class="hljs-keyword">on</span> schedule <span class="hljs-keyword">every</span> <span class="hljs-number">1</span> <span class="hljs-keyword">day</span><br>starts <span class="hljs-string">&#x27;2019-05-22 23:59:59&#x27;</span><br>do<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">call</span> 事件名称 (<span class="hljs-string">&#x27;数据库名&#x27;</span>, <span class="hljs-string">&#x27;分区表名&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">END</span> <span class="hljs-operator">||</span><br>DELIMITER ;<br></code></pre></div></td></tr></table></figure><p>6.删除事件</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> EVENT [IF <span class="hljs-keyword">EXISTS</span>] 事件名称;<br></code></pre></div></td></tr></table></figure><p>7.查看事件</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> event;<br></code></pre></div></td></tr></table></figure><p>8.表分区查看</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">explain partitions <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 分区表名;<br></code></pre></div></td></tr></table></figure><hr><p>原文链接：<a href="https://blog.csdn.net/qq_36216193/article/details/90412637" title="mysql 表分区、按时间函数分区、删除分区、自动添加表分区">mysql 表分区、按时间函数分区、删除分区、自动添加表分区</a></p><p>推荐阅读：</p><ul><li><a href="https://blog.csdn.net/JesseYoung/article/details/35257527">https://blog.csdn.net/JesseYoung/article/details/35257527</a></li><li><a href="https://blog.csdn.net/qq_36216193/article/details/90412637">https://blog.csdn.net/qq_36216193/article/details/90412637</a></li><li><a href="https://blog.csdn.net/laoyang360/article/details/52886987" title="Mysql数据库表分区深入详解">Mysql数据库表分区深入详解</a></li><li><a href="https://juejin.cn/post/6844903495498203144" title="一个MySQL 5.7 分区表性能下降的案例分析">一个MySQL 5.7 分区表性能下降的案例分析</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>管理分布式Session的几种方式</title>
    <link href="/2022/03/17/%E7%AE%A1%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8FSession%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/03/17/%E7%AE%A1%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8FSession%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/Ziki_zhouyuxin/ArticleImages/raw/master/202201272149848.png" srcset="/img/loading.gif" lazyload></p><p>分布式Session实现方式：</p><h2 id="1-客户端存储"><a href="#1-客户端存储" class="headerlink" title="1.客户端存储"></a>1.客户端存储</h2><p>(基于Cookie管理)</p><p>这种方式每次发起请求的时候都需要将Session数据放到Cookie中传递给服务端。</p><ul><li><p>优点：不需要依赖额外外部存储，不需要额外配置。</p></li><li><p>缺点：不安全，易被盗取或篡改；Cookie数量和长度有限制，需要消耗更多网络带宽。</p></li><li><p>适用场景：数据不重要、不敏感且数据量小的情况。</p></li></ul><hr><h2 id="2-Session复制"><a href="#2-Session复制" class="headerlink" title="2.Session复制"></a>2.Session复制</h2><p>在支持Session复制的Web服务器上，通过修改Web服务器的配置，可以实现将Session同步到其它Web服务器上，达到每个Web服务器上都保存一致的Session。</p><p><img src="https://gitee.com/Ziki_zhouyuxin/ArticleImages/raw/master/20210530174912.png" srcset="/img/loading.gif" lazyload></p><ul><li><p>优点：代码上不需要做支持和修改。</p></li><li><p>缺点：需要依赖支持的Web服务器，一旦更换成不支持的Web服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，会造成服务器内存浪费。</p></li><li><p>适用场景：只适用于Web服务器比较少且<code>Session</code>数据量少的情况。</p></li><li><p>可用方案：开源方案<code>tomcat-redis-session-manager</code>。</p></li></ul><hr><h2 id="3-Session粘滞"><a href="#3-Session粘滞" class="headerlink" title="3.Session粘滞"></a>3.Session粘滞</h2><p>将用户的每次请求都通过某种方法强制·分发到某一个Web服务器上，只要这个Web服务器上存储了对应Session数据，就可以实现会话跟踪。</p><ul><li><p>优点：使用简单，没有额外开销。</p></li><li><p>缺点：一旦某个Web服务器重启或宕机，相对应的Session数据将会丢失，而且需要依赖负载均衡机制。</p></li><li><p>适用场景：发生故障对客户产生的影响较小；对稳定性要求不是很高的业务情景。</p></li><li><p>可用方案：以<code>Nginx</code>为例，在<code>upstream</code>模块配置ip_hash属性即可实现粘性Session。</p></li></ul><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">upstream mycluster&#123;<br>    #这里添加的是上面启动好的两台Tomcat服务器<br>    ip_hash;#粘性Session<br>    <span class="hljs-built_in"> server </span>192.168.22.229:8080 <span class="hljs-attribute">weight</span>=1;<br>    <span class="hljs-built_in"> server </span>192.168.22.230:8080 <span class="hljs-attribute">weight</span>=1;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>利用<code>Nginx</code>服务器的反向代理，将服务器A和服务器B进行代理，然后采用<code>ip_hash</code>的负载策略，将客户端和服务器进行绑定，也就是说客户端A第一次访问的是服务器B，那么第二次访问也必然是服务器B，这样就不存在session不一致的问题了。</p><p><img src="https://gitee.com/Ziki_zhouyuxin/ArticleImages/raw/master/20210530174915.png" srcset="/img/loading.gif" lazyload></p><hr><h2 id="4-Session集中管理"><a href="#4-Session集中管理" class="headerlink" title="4.Session集中管理"></a>4.Session集中管理</h2><p>在单独的服务器或服务器集群上使用缓存技术，如<code>Redis</code>存储Session数据，集中管理所有的Session，所有的Web服务器都从这个存储介质中存取对应的Session，实现Session共享。</p><p>这也是目前企业开发用到的比较多的一种分布式<code>session</code>解决方案。</p><p><img src="https://gitee.com/Ziki_zhouyuxin/ArticleImages/raw/master/20210530174917.png" srcset="/img/loading.gif" lazyload></p><ul><li><p>优点：可靠性高，减少Web服务器的资源开销。</p></li><li><p>缺点：实现上有些复杂，配置较多。</p></li><li><p>适用场景：Web服务器较多、要求高可用性的情况。</p></li><li><p>可用方案：开源方案Spring Session等。</p></li></ul><hr><p>参考：</p><ul><li><a href="https://www.cnblogs.com/daofaziran/p/10933221.html">https://www.cnblogs.com/daofaziran/p/10933221.html</a></li><li><a href="https://blog.csdn.net/javandroid/article/details/52959105">https://blog.csdn.net/javandroid/article/details/52959105</a></li><li><a href="https://www.jianshu.com/p/3dd4e06bdfa4">https://www.jianshu.com/p/3dd4e06bdfa4</a></li><li><a href="https://www.cnblogs.com/saoyou/p/11107488.html">https://www.cnblogs.com/saoyou/p/11107488.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Session</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长有效括号</title>
    <link href="/2021/08/29/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <url>/2021/08/29/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>s[i]</code> 为 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> longestValidParentheses(String s) &#123;<br>        Stack&lt;<span class="hljs-type">Integer</span>&gt; st = <span class="hljs-built_in">new</span> Stack&lt;<span class="hljs-type">Integer</span>&gt;();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ,start = <span class="hljs-number">0</span>;i &lt; s.length();i ++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>( s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) st.<span class="hljs-keyword">add</span>(i);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(!st.isEmpty()) <br>                &#123;<br>                    st.pop();<br>                    <span class="hljs-keyword">if</span>(st.isEmpty()) ans = Math.max(ans,i - <span class="hljs-keyword">start</span> + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">else</span> ans = Math.max(ans,i - st.peek());<br>                &#125;<br>                <span class="hljs-keyword">else</span> start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="具体过程如下："><a href="#具体过程如下：" class="headerlink" title="具体过程如下："></a>具体过程如下：</h3><ul><li><p>用栈维护当前待匹配的左括号的位置，同时用 start 记录一个新的可能合法的子串的起始位置，初始设为0。</p></li><li><p>如果s[i] ==’(‘，那么把i进栈。</p></li><li><p>如果s[i] == ‘)’,那么弹出栈顶元素 （代表栈顶的左括号匹配到了右括号），出栈后：</p></li></ul><p>如果栈为空，说明以当前右括号为右端点的合法括号序列的左端点为start，则更新答案 i - start + 1。</p><p>如果栈不为空，说明以当前右括号为右端点的合法括号序列的左端点为栈顶元素的下一个元素，则更新答案i - st.top() 。</p><p><img src="https://pic.leetcode-cn.com/1628390397-QMdXtd-file_1628390396777" srcset="/img/loading.gif" lazyload></p><ul><li><p>遇到右括号)且当前栈为空，则当前的 start 开始的子串不再可能为合法子串了，下一个合法子串的起始位置是 i + 1，更新 start = i + 1。</p></li><li><p>最后返回答案。</p></li></ul><p>实现细节： 栈保存的是下标。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>时间复杂度： O(n)，n 是给定字符串的长度。我们只需要遍历字符串一次即可。</p></li><li><p>空间复杂度： O(n)。栈的大小在最坏情况下会达到 n，因此空间复杂度为 O(n) 。</p></li></ul><hr><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号 - 力扣（LeetCode） (leetcode-cn.com)</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Stream ToMap(Collectors.toMap)</title>
    <link href="/2021/08/29/Stream%20ToMap(Collectors.toMap)/"/>
    <url>/2021/08/29/Stream%20ToMap(Collectors.toMap)/</url>
    
    <content type="html"><![CDATA[<h1 id="Stream-ToMap-Collectors-toMap"><a href="#Stream-ToMap-Collectors-toMap" class="headerlink" title="Stream ToMap(Collectors.toMap)"></a>Stream ToMap(Collectors.toMap)</h1><h2 id="List-TO-Map"><a href="#List-TO-Map" class="headerlink" title="List TO Map"></a>List TO Map</h2><p>List Stream 转换 Map时向collect()方法中传递Collector对象，对象由Collectors.toMap()方法返回。</p><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;GroupBrandCateBO&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(  <br>      Arrays.asList(  <br>              <span class="hljs-keyword">new</span> GroupBrandCateBO(<span class="hljs-string">&quot;v1&quot;</span>, <span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;b1&quot;</span>),  <br>              <span class="hljs-keyword">new</span> GroupBrandCateBO(<span class="hljs-string">&quot;v1&quot;</span>, <span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;b1&quot;</span>),  <br>              <span class="hljs-keyword">new</span> GroupBrandCateBO(<span class="hljs-string">&quot;v3&quot;</span>, <span class="hljs-string">&quot;g3&quot;</span>, <span class="hljs-string">&quot;b3&quot;</span>)  <br>      )  <br>);  <br>    Map&lt;String, String&gt; map = list.stream().collect(Collectors.toMap(item -&gt; item.getVersion(), item -&gt; item.getGroupCode(), (oldVal, currVal) -&gt; oldVal, LinkedHashMap::<span class="hljs-keyword">new</span>));   <br>       System.out.println(map.getClass());  <br>    Map&lt;String, String&gt; map0 = list.stream().collect(Collectors.toMap(item -&gt; item.getVersion(), item -&gt; item.getGroupCode(), (oldVal, currVal) -&gt; oldVal));  <br>      System.out.println(map0.getClass());  <br>      System.out.println(map0.toString());  <br>    Map&lt;String, String&gt; map1 = list.stream().collect(Collectors.toMap(GroupBrandCateBO::getVersion, GroupBrandCateBO::getGroupCode));  <br>      System.out.println(map1.toString());  <br>  <br></code></pre></div></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当存在Key相同的情况下会出现如下异常：</p><p>Exception in thread “main” java.lang.IllegalStateException: Duplicate key……</p><hr><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>toMap()函数重载：<br>未指定合并函数mergeFunction情况下，传入throwingMerger()返回BinaryOperator对象，当出现key重复时，调用合并函数！<br>未指定Supplier实例情况下，默认生成HashMap实例！</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, U&gt;  <br>    Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; keyMapper,  <br>                                Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; valueMapper) &#123;  <br>    <span class="hljs-keyword">return</span> toMap(keyMapper, valueMapper, throwingMerger(), HashMap::<span class="hljs-keyword">new</span>);  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, U&gt;  <br>    Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; keyMapper,  <br>                                Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; valueMapper,  <br>                                BinaryOperator&lt;U&gt; mergeFunction) &#123;  <br>    <span class="hljs-keyword">return</span> toMap(keyMapper, valueMapper, mergeFunction, HashMap::<span class="hljs-keyword">new</span>);  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, U, M extends Map&lt;K, U&gt;&gt;  <br>    Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; keyMapper,  <br>                            Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; valueMapper,  <br>                            BinaryOperator&lt;U&gt; mergeFunction,  <br>                            Supplier&lt;M&gt; mapSupplier) &#123;  <br>    BiConsumer&lt;M, T&gt; accumulator  <br>            = (map, element) -&gt; map.merge(keyMapper.apply(element),  <br>                                          valueMapper.apply(element), mergeFunction);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CollectorImpl&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);  <br>&#125;  <br>  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">BinaryOperator&lt;T&gt; <span class="hljs-title">throwingMerger</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">return</span> (u,v) -&gt; &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(String.format(<span class="hljs-string">&quot;Duplicate key %s&quot;</span>, u)); &#125;;  <br>&#125;  <br><br></code></pre></div></td></tr></table></figure><hr><p>解决方案：<br>加上：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">(oldVal, currVal) -&gt; currVal) <span class="hljs-comment">// key相同时当前值替换原始值  </span><br>(oldVal, currVal) -&gt; oldVal + currVal <span class="hljs-comment">//key相同时保留原始值和当前值，合并value！！！！！！  </span><br></code></pre></div></td></tr></table></figure><p><em><strong>注：合并的是值value，而不是key！！！</strong></em></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kafka如何保证消息不丢失</title>
    <link href="/2021/08/29/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/"/>
    <url>/2021/08/29/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>kafka对于消息的可靠性保证。作为消息组件，保证消息不丢失，是非常重要的。</p><p>那么kafka是如何保证消息不丢失的呢？</p><hr><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>任何消息组件不丢数据都是在特定场景下一定条件的，<code>kafka</code>要保证消息不丢，有两个核心条件。</p><h3 id="第一-必须是已提交的消息即committed-message"><a href="#第一-必须是已提交的消息即committed-message" class="headerlink" title="第一.必须是已提交的消息即committed message"></a>第一.必须是已提交的消息即committed message</h3><p><code>kafka</code>对于<code>committed message</code>的定义是，生产者提交消息到<code>broker</code>，并等到多个<code>broker</code>确认并返回给生产者已提交的确认信息。而这<code>多个broker</code>是由我们自己来定义的，可以选择只要有一个<code>broker</code>成功保存该消息就算是已提交，也可以是令所有<code>broker</code>都成功保存该消息才算是已提交。不论哪种情况，<code>kafka</code>只对已提交的消息做持久化保证。</p><h3 id="第二-N-个broker中至少有-1-个存活"><a href="#第二-N-个broker中至少有-1-个存活" class="headerlink" title="第二.N 个broker中至少有 1 个存活"></a>第二.N 个<code>broker</code>中至少有 1 个存活</h3><p>虽然<code>kafka</code>集群是分布式的，但也必须保证有足够<code>broker</code>正常工作，才能对消息做持久化做保证。也就是说 <code>kafka</code>不丢消息是有前提条件的，假如你的消息保存在 N 个<code>kafka broker</code>上，那么这个前提条件就是这 N 个<code>broker</code>中至少有 1 个存活。只要此条件成立，<code>kafka</code>就能保证你的这条消息永远不会丢失。</p><h2 id="如何保证消息不丢"><a href="#如何保证消息不丢" class="headerlink" title="如何保证消息不丢"></a>如何保证消息不丢</h2><p>一条消息从产生，到发送到<code>kafka</code>保存，到被取出消费，会有多个场景和流程阶段，很可能会出现丢失情况，上文描述了消息丢失的几种情况，下面简单介绍下如何保证消息不丢失。</p><h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><p><code>Producer</code>端可能会丢失消息。目前<code>Kafka Producer</code>是异步发送消息的，也就是说如果你调用的是<code>producer.send(msg)</code>这个<code>API</code>，那么它通常会立即返回，但此时你不保证消息发送已成功完成。可能会出现：网络抖动，导致消息压根就没有发送到<code>Broker</code>端；或者消息本身不合规导致<code>Broker</code>拒绝接收（比如消息太大了，超过了<code>Broker</code>的限制）。</p><p>使用<code>producer.send(msg, callback)</code>接口就能避免这个问题，根据回调，一旦出现消息提交失败的情况，就可以有针对性地进行处理。如果是因为那些瞬时错误，<code>Producer</code>重试就可以了；如果是消息不合规造成的，那么调整消息格式后再次发送。总之，处理发送失败的责任在<code>Producer</code>端而非<code>Broker</code>端。当然，如果此时<code>broker</code>宕机，那就另当别论。</p><h3 id="1-send-msg-callback"><a href="#1-send-msg-callback" class="headerlink" title="1.send(msg, callback)"></a>1.send(msg, callback)</h3><p>可以从<code>callback</code>回调中得到该条消息的发送结果，并且<code>callback</code>是异步回调，所以在兼具性能的情况下，也对消息具有比较好的掌控。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ProducerRecord&lt;<span class="hljs-keyword">byte</span>[],<span class="hljs-keyword">byte</span>[]&gt; record = <span class="hljs-keyword">new</span> ProducerRecord&lt;<span class="hljs-keyword">byte</span>[],<span class="hljs-keyword">byte</span>[]&gt;(<span class="hljs-string">&quot;the-topic&quot;</span>, key, value);<br>producer.send(myRecord,<br>          <span class="hljs-keyword">new</span> Callback() &#123;<br>              <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompletion</span><span class="hljs-params">(RecordMetadata metadata, Exception e)</span> </span>&#123;<br>                  <span class="hljs-keyword">if</span>(e != <span class="hljs-keyword">null</span>) &#123;<br>                     e.printStackTrace();<br>                  &#125; <span class="hljs-keyword">else</span> &#123;<br>                     System.out.println(<span class="hljs-string">&quot;The offset of the record we just sent is: &quot;</span> + metadata.offset());<br>                  &#125;<br>              &#125;<br>          &#125;);<br></code></pre></div></td></tr></table></figure><p>当我们通过  <code>send(msg, callback)</code> 是不是就意味着消息一定不丢失了呢？<br>答案明显是：不是!</p><p>我们接着上面，<code>send(msg, callback)</code>里面 <code>callback</code>返回的成功，</p><p>到底是不是真的确保消息万无一失了？答案是否定的！</p><h3 id="2-request-required-acks-参数"><a href="#2-request-required-acks-参数" class="headerlink" title="2.request.required.acks 参数"></a>2.request.required.acks 参数</h3><p>还需要通过 <code>request.required.acks </code>参数来设置数据可靠性的级别！</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">props.put(<span class="hljs-string">&quot;acks&quot;</span>, <span class="hljs-string">&quot;all&quot;</span>);<span class="hljs-comment">//或者-1</span><br></code></pre></div></td></tr></table></figure><ul><li>1（默认）：这意味着 producer 在 <code>ISR副本同步队列</code>中的 leader 已成功收到的数据并得到确认后发送下一条 message。如果 leader 宕机了，则会丢失数据。</li><li>0：这意味着 producer 无需等待来自 broker 的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</li><li>-1：producer 需要等待 ISR 中的所有 follower都确认接收到数据后才算一次发送完成，可靠性最高。<strong>但是这样也不能保证数据不丢失</strong>，比如当 ISR 中只有 leader时（ISR 中的成员由于某些情况会增加也会减少，最少就只剩一个 leader），这样就变成了 acks=1 的情况。</li></ul><p>如果要提高数据的可靠性，在设置 <code>request.required.acks=-1</code> 的同时，也要设置最小写入副本数的个数<code>min.insync.replicas</code> 参数 (可以在<code>broker</code>或者 <code>topic</code> 层面进行设置) 的配合，这样才能发挥最大的功效。</p><p><code>min.insync.replicas</code> 这个参数设定 <code>ISR</code> 中的最小副本数是多少，默认值为 1，当且仅当 <code>request.required.acks</code> 参数设置为 -1 时，此参数才生效。</p><p>如果 ISR 中的副本数少于 <code>min.insync.replicas</code> 配置的数量时，客户端会返回异常：org.apache.kafka.common.errors.NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required。</p><h3 id="Broker-端的配置"><a href="#Broker-端的配置" class="headerlink" title="Broker 端的配置"></a>Broker 端的配置</h3><p>其实到这里，生产者端基本已经做好了数据不丢失的大部分准备，但是有些东西是要配合Broker 端一起，才能达到预期的不丢失数据的， 比如上面说到的</p><ul><li><p><code>min.insync.replicas</code> 配置<br>我们上面知道，当 生产者 <code>acks = -1</code> 的时候，写入的副本数就必须 &gt;= <code>min.insync.replicas</code> 数，<br>当达不到这个要求的时候，生产者端会收到一个<code>either NotEnoughReplicas or NotEnoughReplicasAfterAppend</code>的异常。</p><p>所以我们这个<code>min.insync.replicas</code>参数必须不能大于数据冗余备份数 <code>replication.factor</code> 。否则生产者将无法写入任何数据，一般建议 <code>replication.factor</code> 数要大于 <code>min.insync.replicas</code>，比如3个机器的集群，设置 <code>replication.factor</code> = 3，那么设置 <code>min.insync.replicas</code> = 2 即可，这样既保证了数据write的时候有一个副本的冗余，也能保证在一些情况下，某台Broker宕机导致数据无法达到3个副本时，依然可以正常write数据。</p></li><li><p><code>unclean.leader.election.enable</code><br>这里 Broker 端还有一个重要的配置就是 <code>unclean.leader.election.enable = false</code><br>这个配置代表着一些数据落后比较多的 follower，是否能在leader宕机后被选举成新的 leader，如果你设置成 true，很明显，如果这样的follower成为新leader，就会造成最新的一部分数据丢失掉，</p></li></ul><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p><code>Consumer</code>端丢数据的情况稍微复杂些。<code>Consumer</code>”位移“(<code>offset</code>)，表示<code>Consumer</code>当前消费到<code>topic</code>分区的哪个位置。</p><p><code>kafka</code>通过先消费消息，后更新<code>offset</code>，来保证消息不丢失。但是这样可能会出现消息重复的情况，具体如何保证<code>only-once</code>,前文已提到过。</p><p>当我们<code>consumer</code>端开启多线程异步去消费时，情况又会变得复杂一些。此时<code>consumer</code>自动地向前更新<code>offset</code>，假如其中某个线程运行失败了，它负责的消息没有被成功处理，但位移已经被更新了，因此这条消息对于<code>consumer</code>而言实际上是丢失了。</p><p>这里的关键就在自动提交<code>offset</code>，如何真正地确认消息是否真的被消费，再进行更新<code>offset</code>。此问题的解决方式：如果是多线程异步处理消费消息，<code>consumer</code>不要开启自动提交<code>offset</code>，<code>consumer</code>端程序自己来处理<code>offset</code>的提交更新。</p><h2 id="实践配置"><a href="#实践配置" class="headerlink" title="实践配置"></a>实践配置</h2><p>最后分享下<code>kafka</code>无消息丢失配置：</p><ul><li><code>producer</code>端使用<code>producer.send(msg, callback)</code>带有回调的<code>send</code>方法。</li><li>设置<code>acks = all</code>。<code>acks</code>是<code>Producer</code>的一个参数，代表“已提交”消息的定义。如果设置成<code>all</code>，则表明所有<code>Broker</code>都要接收到消息，该消息才算是“已提交”。</li><li>设置<code>retries</code>为一个较大的值。同样是<code>Producer</code>的参数。当出现网络抖动时，消息发送可能会失败，此时配置了<code>retries</code>的<code>Producer</code>能够自动重试发送消息，尽量避免消息丢失。</li><li>设置<code>unclean.leader.election.enable = false</code>。这是<code>Broker</code>端的参数，在<code>kafka</code>版本迭代中社区也多次反复修改过他的默认值，之前比较具有争议。它控制哪些<code>Broker</code>有资格竞选分区的<code>Leader</code>。如果一个<code>Broker</code>落后原先的<code>Leader</code>太多，那么它一旦成为新的<code>Leader</code>，将会导致消息丢失。故一般都要将该参数设置成<code>false</code>！！！</li><li>设置<code>replication.factor &gt;= 3</code>。这也是<code>Broker</code>端的参数。保存多份消息冗余。</li><li>设置<code>min.insync.replicas &gt; 1</code>。<code>Broker</code>端参数，控制消息至少要被写入到多少（一个以上）个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在生产环境中不要使用默认值 1 ！！！确保<code>replication.factor &gt; min.insync.replicas</code>。如果两者相等，那么只要有一个副本离线，整个分区就无法正常工作了。推荐设置成<code>replication.factor = min.insync.replicas + 1</code>。</li><li>确保消息消费完成再提交。<code>Consumer</code>端有个参数<code>enable.auto.commit</code>，最好设置成<code>false</code>，并自己来处理<code>offset</code>的提交更新。</li></ul><hr><p>参考文献</p><ul><li><p><a href="https://kafka.apache.org/documentation/#clientconfig">Apache Kafka</a></p></li><li><p><a href="https://www.zhouyuxin.net/article/137">kafka 如何解决消息队列重复消费 (zhouyuxin.net)</a></p></li><li><p><a href="https://www.infoq.cn/article/depth-interpretation-of-kafka-data-reliability">Kafka数据可靠性深度解读-InfoQ</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1589157">kafka是如何保证消息不丢失的 - 云+社区 - 腾讯云 (tencent.com)</a></p></li><li><p><a href="https://www.jianshu.com/p/4e6f01b4259d">Kafka保证消息不丢失不重复 - 简书 (jianshu.com)</a></p></li><li><p><a href="https://www.jianshu.com/p/68c173e4c549">Kafka ——如何保证消息不会丢失 - 简书 (jianshu.com)</a></p></li><li><p><a href="https://www.cnblogs.com/gaopengpy/p/13516216.html">kafka如何保证消息队列不丢失? - gaopengpy - 博客园 (cnblogs.com)</a></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
